<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
  PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1">
        <title id="ay20941">ALTER TABLE</title>
        <body>
                <p id="sql_command_desc">更改一个表的定义。</p>
                <section id="section2">
                        <title>概要</title>
                        <codeblock id="sql_command_synopsis">ALTER TABLE [IF EXISTS] [ONLY] <varname>name</varname> 
    <varname>action</varname> [, ... ]

ALTER TABLE [IF EXISTS] [ONLY] <varname>name</varname> 
    RENAME [COLUMN] <varname>column_name</varname> TO <varname>new_column_name</varname>

ALTER TABLE [ IF EXISTS ] [ ONLY ] <varname>name</varname> 
    RENAME CONSTRAINT <varname>constraint_name</varname> TO <varname>new_constraint_name</varname>

ALTER TABLE [IF EXISTS] <varname>name</varname> 
    RENAME TO <varname>new_name</varname>

ALTER TABLE [IF EXISTS] <varname>name</varname> 
    SET SCHEMA <varname>new_schema</varname>

ALTER TABLE ALL IN TABLESPACE <varname>name</varname> [ OWNED BY <varname>role_name</varname> [, ... ] ]
    SET TABLESPACE <varname>new_tablespace</varname> [ NOWAIT ]

ALTER TABLE [IF EXISTS] [ONLY] <varname>name</varname> SET 
     WITH (REORGANIZE=true|false)
   | DISTRIBUTED BY ({<varname>column_name</varname> [<varname>opclass</varname>]} [, ... ] )
   | DISTRIBUTED RANDOMLY
   | DISTRIBUTED REPLICATED 

ALTER TABLE <varname>name</varname>
   [ ALTER PARTITION { <varname>partition_name</varname> | FOR (RANK(<varname>number</varname>)) 
   | FOR (<varname>value</varname>) } <varname>partition_action</varname> [...] ] 
   <varname>partition_action</varname>

其中 <varname>action</varname> 是下列之一：
                        
  ADD [COLUMN] <varname>column_name data_type</varname> [ DEFAULT <varname>default_expr</varname> ]
      [<varname>column_constraint</varname> [ ... ]]
      [ COLLATE <varname>collation</varname> ]
      [ ENCODING ( <varname>storage_directive</varname> [,...] ) ]
  DROP [COLUMN] [IF EXISTS] <varname>column_name</varname> [RESTRICT | CASCADE]
  ALTER [COLUMN] <varname>column_name</varname> [ SET DATA ] TYPE <varname>type</varname> [COLLATE <varname>collation</varname>] [USING <varname>expression</varname>]
  ALTER [COLUMN] <varname>column_name</varname> SET DEFAULT <varname>expression</varname>
  ALTER [COLUMN] <varname>column_name</varname> DROP DEFAULT
  ALTER [COLUMN] <varname>column_name</varname> { SET | DROP } NOT NULL
  ALTER [COLUMN] <varname>column_name</varname> SET STATISTICS <varname>integer</varname>
  ALTER [COLUMN] column SET ( <varname>attribute_option</varname> = <varname>value</varname> [, ... ] )
  ALTER [COLUMN] column RESET ( <varname>attribute_option</varname> [, ... ] )
  ADD <varname>table_constraint</varname> [NOT VALID]
  ADD <varname>table_constraint_using_index</varname>
  VALIDATE CONSTRAINT <varname>constraint_name</varname>
  DROP CONSTRAINT [IF EXISTS] <varname>constraint_name</varname> [RESTRICT | CASCADE]
  DISABLE TRIGGER [<varname>trigger_name</varname> | ALL | USER]
  ENABLE TRIGGER [<varname>trigger_name</varname> | ALL | USER]
  CLUSTER ON <varname>index_name</varname>
  SET WITHOUT CLUSTER
  SET WITH OIDS
  SET WITHOUT OIDS
  SET (<varname>storage_parameter</varname> = <varname>value</varname>)
  RESET (<varname>storage_parameter</varname> [, ... ])
  INHERIT <varname>parent_table</varname>
  NO INHERIT <varname>parent_table</varname>
  OF <codeph>type_name</codeph>
  NOT OF
  OWNER TO <varname>new_owner</varname>
  SET TABLESPACE <varname>new_tablespace</varname></codeblock>
                        <p>where <varname>partition_action</varname> is one of:</p>
                        <codeblock>  ALTER DEFAULT PARTITION
  DROP DEFAULT PARTITION [IF EXISTS]
  DROP PARTITION [IF EXISTS] { <varname>partition_name</varname> | 
      FOR (RANK(<varname>number</varname>)) | FOR (<varname>value</varname>) } [CASCADE]
  TRUNCATE DEFAULT PARTITION
  TRUNCATE PARTITION { <varname>partition_name</varname> | FOR (RANK(<varname>number</varname>)) | 
      FOR (<varname>value</varname>) }
  RENAME DEFAULT PARTITION TO <varname>new_partition_name</varname>
  RENAME PARTITION { <varname>partition_name</varname> | FOR (RANK(<varname>number</varname>)) | 
      FOR (<varname>value</varname>) } TO <varname>new_partition_name</varname>
  ADD DEFAULT PARTITION <varname>name</varname> [ ( <varname>subpartition_spec</varname> ) ]
  ADD PARTITION [<varname>partition_name</varname>] <varname>partition_element</varname>
     [ ( <varname>subpartition_spec</varname> ) ]
  EXCHANGE PARTITION { <varname>partition_name</varname> | FOR (RANK(<varname>number</varname>)) | 
       FOR (<varname>value</varname>) } WITH TABLE <varname>table_name</varname>
        [ WITH | WITHOUT VALIDATION ]
  EXCHANGE DEFAULT PARTITION WITH TABLE <varname>table_name</varname>
   [ WITH | WITHOUT VALIDATION ]
  SET SUBPARTITION TEMPLATE (<varname>subpartition_spec</varname>)
  SPLIT DEFAULT PARTITION
    {  AT (<varname>list_value</varname>)
     | START([<varname>datatype</varname>] <varname>range_value</varname>) [INCLUSIVE | EXCLUSIVE] 
        END([<varname>datatype</varname>] <varname>range_value</varname>) [INCLUSIVE | EXCLUSIVE] }
    [ INTO ( PARTITION <varname>new_partition_name</varname>, 
             PARTITION <varname>default_partition_name</varname> ) ]
  SPLIT PARTITION { <varname>partition_name</varname> | FOR (RANK(<varname>number</varname>)) | 
     FOR (<varname>value</varname>) } AT (<varname>value</varname>) 
    [ INTO (PARTITION <varname>partition_name</varname>, PARTITION <varname>partition_name</varname>)]  </codeblock>
                        <p>where <varname>partition_element</varname> is:</p>
                        <codeblock>    VALUES (<varname>list_value</varname> [,...] )
  | START ([<varname>datatype</varname>] '<varname>start_value</varname>') [INCLUSIVE | EXCLUSIVE]
     [ END ([<varname>datatype</varname>] '<varname>end_value</varname>') [INCLUSIVE | EXCLUSIVE] ]
  | END ([<varname>datatype</varname>] '<varname>end_value</varname>') [INCLUSIVE | EXCLUSIVE]
[ WITH ( <varname>partition_storage_parameter</varname>=<varname>value</varname> [, ... ] ) ]
[ TABLESPACE <varname>tablespace</varname> ]</codeblock>
                        <p>where <varname>subpartition_spec</varname> is:</p>
                        <codeblock><varname>subpartition_element</varname> [, ...]</codeblock>
                        <p>and <varname>subpartition_element</varname> is:</p>
                        <codeblock>   DEFAULT SUBPARTITION <varname>subpartition_name</varname>
  | [SUBPARTITION <varname>subpartition_name</varname>] VALUES (<varname>list_value</varname> [,...] )
  | [SUBPARTITION <varname>subpartition_name</varname>] 
     START ([<varname>datatype</varname>] '<varname>start_value</varname>') [INCLUSIVE | EXCLUSIVE]
     [ END ([<varname>datatype</varname>] '<varname>end_value</varname>') [INCLUSIVE | EXCLUSIVE] ]
     [ EVERY ( [<varname>number | datatype</varname>] '<varname>interval_value</varname>') ]
  | [SUBPARTITION <varname>subpartition_name</varname>] 
     END ([<varname>datatype</varname>] '<varname>end_value</varname>') [INCLUSIVE | EXCLUSIVE]
     [ EVERY ( [<varname>number | datatype</varname>] '<varname>interval_value</varname>') ]
[ WITH ( <varname>partition_storage_parameter</varname>=<varname>value</varname> [, ... ] ) ]
[ TABLESPACE <varname>tablespace</varname> ]</codeblock>
                        <p>where <varname>storage_parameter</varname> is:</p>
                        <codeblock>   appendoptimized={TRUE|FALSE}
   blocksize={8192-2097152}
   orientation={COLUMN|ROW}
   compresstype={ZLIB|ZSTD|QUICKLZ|RLE_TYPE|NONE}
   compresslevel={0-9}
   fillfactor={10-100}
   oids[=TRUE|FALSE]</codeblock>
                </section>
                <section id="section3">
                        <title>描述</title>
                        <p><codeph>ALTER TABLE</codeph> 更改一个表的定义。下文描述了几种形式： </p>
                        <ul>
                                <li id="ay136723"><b>ADD COLUMN</b> — 向表中增加一个新列，使用和<codeph><xref
                                                  href="CREATE_TABLE.xml">CREATE
                                                TABLE</xref></codeph>相同的语义。<codeph>ENCODING</codeph>
                                        子句只有在追加和列存储表中有效</li>
                                <li><b>DROP COLUMN [IF EXISTS]</b> — 从表中删除列。 请注意，如果删除用作Greenplum数据库分配键的表列，则表的分配策略将更改为<codeph>DISTRIBUTED RANDOMLY</codeph>.。 涉及该列的索引和表约束也会自动删除。 如果表外的任何内容都取决于列（例如视图），则需要指定<codeph>CASCADE</codeph>。 如果指定了<codeph>IF
                                                EXISTS</codeph>且该列不存在，则不会引发任何错误； 而是发出通知。</li>
                                <li><b>IF EXISTS</b> — 如果表不存在，请不要抛出错误。 在这种情况下发出通知。</li>
                                <li id="ay136879"><b>SET DATA TYPE</b> — 此表单更改表的列的数据类型。 请注意，您不能更改用作分发键或分区键的列数据类型。 通过重新解析最初提供的表达式，涉及该列的索引和简单表约束将自动转换为使用新的列类型。 可选的<codeph>COLLATE</codeph>子句为新列指定排序规则，如果省略，则排序规则是新列类型的默认排序规则。 可选的<codeph>USING</codeph>子句指定如何从旧的值计算新的列值。 如果省略，则默认转换与从旧数据类型到新数据类型的转换相同。 如果没有从旧类型转换为新类型的隐式或赋值，则必须提供<codeph>USING</codeph>子句。<note>仅当查询中的所有列使用相同的排序规则时，GPORCA才支持排序规则。 如果查询中的列使用不同的排序规则，则Greenplum使用Postgres Planner。</note></li>
                                <li id="ay136904"><b>SET/DROP DEFAULT</b> — 设置或删除列的默认值。 默认值仅适用于后续的<codeph>INSERT</codeph>或<codeph>UPDATE</codeph>命令。 它们不会导致表中已有的行发生更改。</li>
                                <li id="ay136929"><b>SET/DROP NOT NULL</b> — 更改是将列标记为允许空值还是拒绝空值。 当列不包含空值时，只能使用<codeph>SET NOT NULL</codeph>。</li>
                                <li id="ay136944"><b>SET STATISTICS</b> — 为后续的<codeph>ANALYZE</codeph>操作设置每个列的统计信息收集目标。 可以在100到10000的范围内设置目标，也可以设置为-1以使用系统默认统计信息目标（<codeph>default_statistics_target</codeph>）恢复为目标。</li>
                                <li>
                                        <p><b>SET ( <varname>attribute_option</varname> =
                                                  <varname>value</varname> [, ... ]) </b></p>
                                        <p><b>RESET ( <varname>attribute_option [, ...]
                                                  )</varname></b>— 
												设置或重置每个属性选项。当前，唯一定义的按属性的选项是 <codeph>n_distinct</codeph> 和<codeph>n_distinct_inherited</codeph>，它们覆盖了后续 <codeph><xref
                                                  href="ANALYZE.xml#topic1">ANALYZE</xref></codeph> 操作所做的不同值估计数。 <codeph>n_distinct</codeph>  影响表本身的统计信息，而<codeph>n_distinct_inherited</codeph>影响表及其继承子级收集的统计信息。当设置为正值时，<codeph>ANALYZE</codeph>将假定该列恰好包含指定数量的不同非空值。当设置为负值（必须大于或等于-1）时，<codeph>ANALYZE</codeph>将假定列中不同的非空值的数量在表的大小中是线性的；确切的计数应通过将估计的表大小乘以给定数字的绝对值来计算。例如，值-1表示该列中的所有值都是不同的，而值-0.5表示每个值平均出现两次。当表的大小随时间变化时，这很有用，因为直到查询计划时间才执行表中行数的乘法。将值指定为0可恢复为通常估计不同值的数量</p>
                                </li>
                                <li id="ay137022"><b>ADD <varname>table_constraint</varname> [NOT
                                                VALID]</b> — 使用与<codeph>CREATE
                                                TABLE</codeph>相同的语法向表（不仅仅是分区）添加新约束。 当前仅将<codeph>NOT VALID</codeph>选项用于外键和<codeph>CHECK</codeph>约束。 如果约束标记为<codeph>NOT VALID</codeph>，则Greenplum数据库将跳过可能冗长的初始检查，以验证表中的所有行均满足约束。 约束将仍然针对后续的插入或更新（即，对于外键而言，除非在引用表中有匹配的行，否则它们将失败；对于外键，除非新行与指定的检查匹配，否则它们将失败） 约束）。 但是，除非使用<codeph>VALIDATE
                                                CONSTRAINT</codeph>选项对其进行验证，否则数据库将不假定该约束对表中的所有行均有效。 创建表时将跳过约束检查，因此<xref
                                                href="CREATE_TABLE.xml#topic1"/>语法不包括此选项。</li>
                                <li><b>VALIDATE CONSTRAINT</b> — 该形式通过扫描表以确保没有不满足该约束的行，从而验证了以前创建为<codeph>NOT
                                                VALID</codeph>的外键约束。 如果约束已被标记为有效，则什么也不会发生。 将验证与约束的初始创建分开的好处是，与约束创建相比，验证对表的锁定更少。</li>
                                <li><b>ADD <varname>table_constraint_using_index</varname></b> —
                                        根据现有的唯一索引将新的 <codeph>PRIMARY KEY</codeph> 或 <codeph>UNIQUE</codeph> 约束添加到表中。 索引的所有列都将包含在约束中。 索引不能具有表达式列，也不能是部分索引。 另外，它必须是具有默认排序顺序的b树索引。 这些限制确保索引等于由常规<codeph>ADD PRIMARY KEY</codeph>或<codeph>ADD UNIQUE</codeph>命令建立的索引。<p>如果指定了 <codeph>PRIMARY KEY</codeph>，并且索引的列尚未标记为<codeph>NOT
                                                  NULL</codeph>，则此命令将尝试对每个此类列执行<codeph>ALTER COLUMN SET NOT NULL</codeph>。 这需要全表扫描，以验证列不包含空值。 在所有其他情况下，这是一个快速的操作。</p><p>如果提供了约束名称，那么索引将被重命名以匹配约束名称。 否则，约束将被命名为与索引相同。</p><p>执行此命令后，索引将由约束“拥有”，就像使用常规 <codeph>ADD PRIMARY KEY</codeph>或<codeph>ADD
                                                  UNIQUE</codeph>命令构建索引一样。 特别是，删除约束将使索引也消失。</p><note>在需要添加新约束而不长时间阻止表更新的情况下，使用现有索引添加约束可能会有所帮助。 为此，请使用<codeph> CREATE INDEX CONCURRENTLY </codeph>创建索引，然后使用此语法将其安装为正式约束。 请参见下面的示例。</note>
                                </li>
                                <li id="ay137038"><b>DROP CONSTRAINT [IF EXISTS]</b> — 将指定的约束放在表上。 如果指定了<codeph>IF
                                                EXISTS</codeph>且该约束不存在，则不会引发任何错误。 在这种情况下，将发出通知。</li>
                                <li id="ay137055"><b>DISABLE/ENABLE TRIGGER</b> — 禁用或启用属于该表的触发器。 禁用的触发器对于系统仍然是已知的，但是在其触发事件发生时不会执行。 对于延迟的触发器，将在事件发生时而不是在实际执行触发器功能时检查启用状态。 可以禁用或启用由名称指定的单个触发器，或表上的所有触发器，或仅由用户创建的触发器。 禁用或启用约束触发器需要超级用户特权。<note> Greenplum数据库中不支持触发器。 由于Greenplum数据库的并行性，触发器通常具有非常有限的功能。</note></li>
                                <li id="ay137071"><b>CLUSTER ON/SET WITHOUT CLUSTER</b> — 选择或删除默认索引以用于将来的<codeph>CLUSTER</codeph>操作。 它实际上并没有重新群集表。 请注意，建议不要使用<codeph>CLUSTER</codeph>对Greenplum数据库中的表进行物理重新排序，因为它会花费很长时间。 最好使用<codeph><xref href="./CREATE_TABLE_AS.xml#topic1"
                                                  type="topic" format="dita"/></codeph>重新创建表并按索引列对其进行排序。<note>追加优化表不支持<codeph>CLUSTER ON</codeph>。</note></li>
                                <li><b>SET WITH OIDS</b> — 往表中添加一个系统列 <codeph>oid</codeph>。如果表中已有OID列则不会做任何操作，
								这与<codeph>ADD COLUMN oid oid</codeph>的操作并不相等，<codeph>ADD COLUMN oid oid</codeph>会增加一个正常的名为<codeph>oid</codeph>的正常列，而不是增加一个系统列。OIDs不允许增加在分区表或者追加优化列组织表。<note
                                                type="warning">Greenplum强烈建议您在创建表时不要启用OIDS。 在大型表（例如典型的Greenplum数据库系统中的表）上，对表行使用OID可能会导致32位OID计数器的折回。 一旦计数器回绕，就不能再认为OID是唯一的，这不仅使OID对用户应用程序无用，而且还会在Greenplum数据库系统目录表中引起问题。 此外，从表中排除OID会使每行将表存储在磁盘上所需的空间减少了每行4个字节，从而略微提高了性能。</note>
                                </li>
                                <li id="ay137152"><b>SET WITHOUT OIDS</b> — 从表中删除OID系统列。</li>
                                <li id="ay137192"><b>SET ( FILLFACTOR = <varname>value</varname>) /
                                                RESET (FILLFACTOR)</b> — 更改表的填充因子。 表格的填充系数是10到100之间的百分比。默认值为100（完全打包）。 当指定较小的填充因子时，<codeph>INSERT</codeph>操作仅将表页面打包到指定的百分比； 每个页面上的剩余空间都保留用于更新该页面上的行。 这样，<codeph>UPDATE</codeph>就有机会将行的更新副本与原始副本放置在同一页面上，这比将其放置在另一页面上更为有效。 对于一个条目从不更新的表，完全打包是最佳选择，但在更新频繁的表中，较小的填充因子是合适的。 请注意，此命令不会立即修改表内容。 您将需要重写表以获得所需的效果。 可以使用<xref href="VACUUM.xml#topic1"/>或强制表重写的<xref href="#topic1" format="dita"/>形式之一来完成。</li>
                                <li id="ay141947"><b>SET DISTRIBUTED</b> — 更改表的分配策略。 更改哈希分发策略，或更改为复制策略或从复制策略更改将导致表数据在磁盘上进行物理重新分发，这可能会占用大量资源。</li>
                                <li id="ay137232"><b>INHERIT <varname>parent_table</varname> / NO
                                                INHERIT <varname>parent_table</varname></b> — 添加或删除目标表作为指定父表的子表。 对父级的查询将包括其子表的记录。 要作为子项添加，目标表必须已经包含与父项相同的所有列（它也可以具有其他列）。 这些列必须具有匹配的数据类型，并且如果它们在父级中具有<codeph>NOT NULL</codeph>约束，那么它们在子级中也必须具有<codeph>NOT NULL</codeph>约束。 对于父级的所有CHECK约束，还必须有匹配的子表约束，但在父级中标记为不可继承的（即用<codeph>ALTER TABLE
                                                ... ADD CONSTRAINT ... NO INHERIT</codeph>创建）的约束除外。 匹配的所有子表约束均不得标记为不可继承。 当前不考虑<codeph>UNIQUE</codeph>,
                                                <codeph>PRIMARY KEY</codeph>和 <codeph>FOREIGN
                                                KEY</codeph>约束，但是将来可能会改变。</li>
                                <li>OF <varname>type_name</varname> — 这种形式将表链接到复合类型，就像<codeph>CREATE TABLE OF</codeph>已经形成了它一样。 该表的列名和类型列表必须与组合类型的列表完全匹配； <codeph>oid</codeph>系统列的存在可以不同。 该表不得从任何其他表继承。 这些限制确保 <codeph>CREATE
                                                TABLE OF</codeph>将允许等效的表定义。</li>
                                <li><b>NOT OF</b> — 这种形式将类型化表与其类型分离。 </li>
                                <li id="ay137262"><b>OWNER</b> — 将表，序列或视图的所有者更改为指定的用户。 </li>
                                <li id="ay137271"><b>SET TABLESPACE</b> — 
								将表的表空间更改为指定的表空间，并将与表关联的数据文件移动到新表空间。表中的索引（如果有）不会移动；但是可以使用其他<codeph>SET
                                                TABLESPACE</codeph>命令分别移动它们。可以使用<codeph>ALL IN TABLESPACE</codeph>表单移动表空间中当前数据库中的所有表，该表单将锁定所有要先移动的表，然后再移动每个表。此表单还支持<codeph>OWNED BY</codeph>，该操作仅移动指定角色所拥有的表。如果指定了<codeph>NOWAIT</codeph>选项，则如果该命令无法立即获取所有必需的锁，则该命令将失败。请注意，此命令不会移动系统目录，请根据需要使用<codeph>ALTER
                                                DATABASE</codeph>或显式<codeph>ALTER
                                                TABLE</codeph>调用。  <codeph>information_schema</codeph>关系不视为系统目录的一部分，将被移动。另请参见<codeph>CREATE TABLESPACE</codeph>。如果更改分区表的表空间，则所有子表分区也将移至新表空间。
                                </li>
                                <li id="ay137292"><b>RENAME</b> — 更改表（或索引，序列或视图）的名称，表中单个列的名称或表的约束的名称。 对存储的数据没有影响。 请注意，Greenplum数据库分发密钥列不能重命名。</li>
                                <li id="ay137307"><b>SET SCHEMA</b> — 将表移到另一个架构。 表列拥有的关联索引，约束和序列也将移动。 </li>
                                <li id="ay139526"><b>ALTER PARTITION | DROP PARTITION | RENAME
                                                PARTITION | TRUNCATE PARTITION | ADD PARTITION |
                                                SPLIT PARTITION | EXCHANGE PARTITION | SET
                                                SUBPARTITION TEMPLATE </b>— 更改分区表的结构。 在大多数情况下，您必须遍历父表才能更改其子表分区之一。</li>
                        </ul>
                        <note>如果将分区添加到具有子分区编码的表中，则新分区将继承该子分区的存储指令。 有关压缩设置优先级的更多信息，请参阅<cite>Greenplum Database Administrator Guide</cite>中的“使用压缩”。</note>
                        <p>除 <codeph>RENAME</codeph>和<codeph>SET SCHEMA</codeph>之外，所有作用于单个表的ALTER TABLE形式都可以组合成多个更改列表以一起应用。 例如，可以在单个命令中添加几列和/或更改几列的类型。 这对于大型表尤其有用，因为只需要对表进行一次遍历。</p>
                        <p>
						您必须拥有该表才能使用<codeph>ALTER TABLE</codeph>。 要更改表的架构或表空间，您还必须对新架构或表空间具有<codeph>CREATE</codeph>特权。 要将表添加为父表的新子级，您还必须拥有父表。 要更改所有者，您还必须是新拥有角色的直接或间接成员，并且该角色必须对表的架构具有<codeph>CREATE</codeph>特权。 要添加列或更改列类型或使用<codeph>OF</codeph>子句，您还必须对数据类型具有<codeph>USAGE</codeph>特权。 超级用户自动具有这些特权。</p>
                        <note>如果表具有多个分区，表具有压缩功能或表的块大小很大，则内存使用量会显着增加。 如果与该表关联的关系的数量很大，则这种情况可能会迫使对该表进行的操作使用更多的内存。 例如，如果该表是一个CO表并具有大量列，则每个列都是一个关系。 诸如<codeph>ALTER TABLE ALTER COLUMN</codeph>之类的操作将打开表中的所有列，以分配关联的缓冲区。 如果CO表具有40列和100个分区，并且这些列被压缩并且块大小为2 MB（系统系数为3），则系统尝试分配24 GB，即（40×100）×（2× 3）MB或24 GB。</note>
                </section>
                <section id="section4">
                        <title>参数</title>
                        <parml>
                                <plentry>
                                        <pt>ONLY</pt>
                                        <pd>仅对指定的表名执行操作。 如果不使用 <codeph>ONLY</codeph>关键字，则将在命名表以及与该表关联的任何子表分区上执行该操作。<note>只允许在父表或子表中添加或删除列，或更改列的类型。 父表及其后代必须始终具有相同的列和类型。</note></pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>name</varname>
                                        </pt>
                                        <pd>要更改的现有表的名称（可能是模式限定的）。 如果<codeph>ONLY</codeph>指定，则仅更改该表。 如果未指定<codeph>ONLY</codeph>，则更新表及其所有后代表（如果有）。
                                                <note type="note">约束只能添加到整个表，不能添加到分区。 由于该限制，<varname>name</varname>参数只能包含表名，而不能包含分区名。</note></pd>
                                </plentry>
                        </parml>
                        <parml>
                                <plentry>
                                        <pt>
                                                <varname>column_name</varname>
                                        </pt>
                                        <pd>新列或现有列的名称。 请注意，Greenplum数据库分发键列必须格外小心。 更改或删除这些列可以更改表的分发策略。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>new_column_name</varname>
                                        </pt>
                                        <pd>现有列的新名称。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>new_name</varname>
                                        </pt>
                                        <pd>表的新名称。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>type</varname>
                                        </pt>
                                        <pd>新列的数据类型，或现有列的新数据类型。 如果更改Greenplum分布键列的数据类型，则只能将其更改为兼容类型（例如，<codeph>text</codeph>到<codeph>varchar</codeph>可以，但<codeph>text</codeph>到<codeph>int</codeph>则不能）。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>table_constraint</varname>
                                        </pt>
                                        <pd>表的新表约束。 请注意，Greenplum数据库当前不支持外键约束。 此外，表仅允许一个唯一约束，并且唯一性必须在Greenplum数据库分发密钥内。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>constraint_name</varname>
                                        </pt>
                                        <pd>要删除的现有约束的名称。</pd>
                                </plentry>
                                <plentry>
                                        <pt>CASCADE</pt>
                                        <pd>自动删除依赖于已删除列或约束的对象（例如，引用该列的视图）。</pd>
                                </plentry>
                                <plentry>
                                        <pt>RESTRICT</pt>
                                        <pd>如果有任何相关对象，则拒绝删除列或约束。 这是默认行为。
                                        </pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>trigger_name</varname>
                                        </pt>
                                        <pd>要禁用或启用的单个触发器的名称。 请注意，Greenplum数据库不支持触发器。</pd>
                                </plentry>
                                <plentry>
                                        <pt>ALL</pt>
                                        <pd>禁用或启用属于该表的所有触发器，包括与约束相关的触发器。 如果任何触发器是内部生成的约束触发器（例如用于实现外键约束或可延迟的唯一性和排除约束的触发器），则这需要超级用户特权。</pd>
                                </plentry>
                                <plentry>
                                        <pt>USER</pt>
                                        <pd>禁用或启用属于该表的所有触发器，但内部生成的约束触发器（例如用于实现外键约束或可延迟的唯一性和排除约束的触发器除外）除外。
                                        </pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>index_name</varname>
                                        </pt>
                                        <pd>表应标记为集群的索引名称。 请注意，建议不要使用<codeph>CLUSTER</codeph>对Greenplum数据库中的表进行物理重新排序，因为它会花费很长时间。 最好使用<codeph><xref href="./CREATE_TABLE_AS.xml#topic1"
                                                  type="topic" format="dita"/></codeph>重新创建表并按索引列对其进行排序。</pd>
                                </plentry>
                                <plentry>
                                        <pt>FILLFACTOR</pt>
                                        <pd>设置表格的填充系数百分比。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>value</varname>
                                        </pt>
                                        <pd> <codeph>FILLFACTOR</codeph>参数的新值，介于10到100之间的百分比。默认值为100。</pd>
                                </plentry>
                                <plentry>
                                        <pt>DISTRIBUTED BY ({<varname>column_name</varname>
                                                  [<varname>opclass</varname>]}) | DISTRIBUTED
                                                RANDOMLY | DISTRIBUTED REPLICATED</pt>
                                        <pd>指定表的分发策略。 更改哈希分发策略会导致物理上重新分配表数据，这可能会占用大量资源。 如果声明相同的哈希分配策略或从哈希更改为随机分配，则除非声明<codeph>SET WITH (REORGANIZE=true)</codeph>，否则不会重新分配数据。</pd>
                                        <pd>更改为复制的分发策略或从复制的分发策略更改将导致表数据被重新分发。</pd>
                                </plentry>
                                <plentry>
                                        <pt>REORGANIZE=true|false</pt>
                                        <pd>当哈希分配策略未更改或从哈希更改为随机分配，并且无论如何都希望重新分配数据时，请使用<codeph>REORGANIZE=true</codeph> 。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>parent_table</varname>
                                        </pt>
                                        <pd>父表要与此表关联或取消关联。 </pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>new_owner</varname>
                                        </pt>
                                        <pd>表的新所有者的角色名称。 </pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>new_tablespace</varname>
                                        </pt>
                                        <pd>该表将被移动到的表空间的名称。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>new_schema</varname>
                                        </pt>
                                        <pd>表将被移动到的模式的名称。
                                        </pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>parent_table_name</varname>
                                        </pt>
                                        <pd>更改分区表时，顶级父表的名称。</pd>
                                </plentry>
                                <plentry>
                                        <pt>ALTER [DEFAULT] PARTITION</pt>
                                        <pd>如果要更改的分区比第一级分区深，请使用<codeph>ALTER PARTITION</codeph>子句指定要更改层次结构中的哪个子分区</pd>
                                </plentry>
                                <plentry>
                                        <pt>DROP [DEFAULT] PARTITION</pt>
                                        <pd>删除指定的分区。 如果分区具有子分区，则子分区也会自动删除。</pd>
                                </plentry>
                                <plentry>
                                        <pt>TRUNCATE [DEFAULT] PARTITION</pt>
                                        <pd>截断指定的分区。 如果分区具有子分区，则子分区也会自动被截断。</pd>
                                </plentry>
                                <plentry>
                                        <pt>RENAME [DEFAULT] PARTITION</pt>
                                        <pd>更改分区的分区名称（而不是关系名称）。 分区表是使用以下命名约定创建的：
                                                  <codeph>&lt;</codeph><varname>parentname</varname><codeph>&gt;_&lt;</codeph><varname>level</varname><codeph>&gt;_prt_&lt;</codeph><varname>partition_name</varname><codeph>&gt;</codeph>.</pd>
                                </plentry>
                                <plentry>
                                        <pt>ADD DEFAULT PARTITION</pt>
                                        <pd>将默认分区添加到现有分区设计中。 当数据与现有分区不匹配时，会将其插入默认分区。 没有默认分区的分区设计将拒绝与现有分区不匹配的传入行。 必须为默认分区指定名称。</pd>
                                </plentry>
                                <plentry>
                                        <pt>ADD PARTITION</pt>
                                        <pd><varname>partition_element</varname> - 使用表（范围或列表）的现有分区类型，定义要添加的新分区的边界。</pd>
                                        <pd><varname>name</varname> - 此新分区的名称。</pd>
                                        <pd><b>VALUES</b> - 对于列表分区，定义分区将包含的值。</pd>
                                        <pd><b>START</b> - 对于范围分区，定义分区的起始范围值。 默认情况下，起始值为<codeph>INCLUSIVE</codeph>。 例如，如果您声明开始日期为“ <codeph>2016-01-01</codeph>”，则分区将包含所有大于或等于“ <codeph>2016-01-01</codeph>”的日期。 通常，<codeph>START</codeph>表达式的数据类型与分区键列的类型相同。 如果不是这种情况，则必须显式转换为预期的数据类型。</pd>
                                        <pd><b>END</b> - 对于范围分区，定义分区的结束范围值。 默认情况下，最终值为<codeph>EXCLUSIVE</codeph>。 例如，如果您声明结束日期为“ '<codeph>2016-02-01</codeph>”，则分区将包含所有小于但不等于“ '<codeph>2016-02-01</codeph>”的日期。 通常， <codeph>END</codeph>表达式的数据类型与分区键列的类型相同。 如果不是这种情况，则必须显式转换为预期的数据类型。</pd>
                                        <pd><b>WITH</b> - 设置分区的表存储选项。 例如，您可能希望将较旧的分区作为追加优化表，而将较新的分区作为常规堆表。 有关存储选项的说明，请参见<codeph><xref href="./CREATE_TABLE.xml#topic1"
                                                  type="topic" format="dita"/></codeph>。</pd>
                                        <pd><b>TABLESPACE</b> - 要在其中创建分区的表空间的名称。</pd>
                                        <pd><varname>subpartition_spec</varname> - 仅允许在没有子分区模板的情况下创建的分区设计。 声明要添加的新分区的子分区规范。 如果分区表最初是使用子分区模板定义的，则该模板将用于自动生成子分区。</pd>
                                </plentry>
                                <plentry>
                                        <pt>EXCHANGE [DEFAULT] PARTITION</pt>
                                        <pd>将另一个表交换到分区层次结构中，替换为现有分区的位置。 在多级分区设计中，您只能交换最低级别的分区（包含数据的分区）。</pd>
                                        <pd>Greenplum数据库服务器配置参数<codeph>gp_enable_exchange_default_partition</codeph>控制<codeph>EXCHANGE
                                                  DEFAULT PARTITION</codeph>子句的可用性。 该参数的默认值是<codeph>off</codeph>。 该子句不可用，如果在<codeph>ALTER TABLE</codeph>命令中指定了该子句，则Greenplum数据库将返回错误。</pd>
                                        <pd>有关该参数的信息，请参阅<xref
                                                  href="../config_params/guc_config.xml#topic1"
                                                  />.<note type="warning">交换默认分区之前，必须确保要交换的表中的数据（新的默认分区）对默认分区有效。 例如，新的默认分区中的数据不得包含在分区表的其他叶子分区中有效的数据。 否则，由GPORCA执行的具有交换的默认分区的分区表查询可能会返回错误的结果。</note></pd>
                                        <pd><b>WITH TABLE</b>
                                                <varname>table_name</varname> - 
												您要交换到分区设计中的表的名称。 您可以交换一个表，其中表数据存储在数据库中。 例如，该表是使用<codeph>CREATE TABLE</codeph>命令创建的。 该表必须具有与父表相同的列数，列顺序，列名，列类型和分发策略。</pd>
                                        <pd>使用<codeph>EXCHANGE PARTITION</codeph>子句，您还可以将可读的外部表（使用<codeph>CREATE EXTERNAL TABLE</codeph>命令创建）交换到分区层次结构中，而不是现有的叶子子分区。 如果您指定了可读的外部表，则还必须指定<codeph>WITHOUT VALIDATION</codeph>子句，以针对要交换的分区的 <codeph>CHECK</codeph>约束跳过表验证。</pd>
                                        <pd>如果分区表包含具有检查约束或<codeph>NOT
                                                  NULL</codeph>约束的列，则不支持与外部表交换叶子分区。</pd>
                                        <pd>您无法与复制表交换分区。 不支持将分区与分区表或分区表的子分区交换。</pd>
                                        <pd><b>WITH</b> | <b>WITHOUT VALIDATION</b> - 验证表中的数据是否与您要交换的分区的<codeph>CHECK</codeph>约束相匹配。 默认设置是根据<codeph>CHECK</codeph>约束验证数据。
                                                  <note type="warning">如果指定<codeph>WITHOUT VALIDATION</codeph>子句，则必须确保针对现有子叶分区交换的表中的数据对于分区上的<codeph>CHECK</codeph>约束是有效的。</note></pd>
                                </plentry>
                                <plentry>
                                        <pt>SET SUBPARTITION TEMPLATE</pt>
                                        <pd>修改现有分区的子分区模板。 设置新的子分区模板后，所有添加的新分区将具有新的子分区设计（现有分区不会被修改）。</pd>
                                </plentry>
                                <plentry>
                                        <pt>SPLIT DEFAULT PARTITION</pt>
                                        <pd>分割默认分区。 在多级分区中，只能拆分范围分区，而不能拆分列表分区，并且只能拆分最低级别的默认分区（包含数据的分区）。 拆分默认分区将创建一个包含指定值的新分区，并保留默认分区，其中包含与现有分区不匹配的任何值。</pd>
                                        <pd><b>AT</b> - 对于列表分区表，指定一个列表值，该值应用作拆分条件。 </pd>
                                        <pd><b>START</b> - 对于范围分区表，指定新分区的起始值。 </pd>
                                        <pd><b>END</b> - 对于范围分区表，指定新分区的结束值。</pd>
                                        <pd><b>INTO</b> - 允许您为新分区指定名称。 使用<codeph>INTO</codeph>子句拆分默认分区时，指定的第二个分区名称应始终为现有默认分区的名称。 如果您不知道默认分区的名称，则可以使用<varname>pg_partitions</varname>视图进行查找。</pd>
                                </plentry>
                                <plentry>
                                        <pt>SPLIT PARTITION</pt>
                                        <pd>将现有分区分为两个分区。 在多级别分区中，只能拆分范围分区，而不能拆分列表分区，并且只能拆分最低级别的分区（包含数据的分区）。 </pd>
                                        <pd><b>AT</b> - 指定一个单一值，该值应用作分割条件。 该分区将分为两个新分区，指定的分割值是后一个分区的起始范围。</pd>
                                        <pd><b>INTO</b> - 允许用户为分裂创建两个新分区指定名字。</pd>
                                </plentry>
                                <plentry>
                                        <pt>
                                                <varname>partition_name</varname>
                                        </pt>
                                        <pd>给定的分区名称。</pd>
                                </plentry>
                                <plentry>
                                        <pt>FOR (RANK(number))</pt>
                                        <pd>对于范围分区，分区在范围中的排名。</pd>
                                </plentry>
                                <plentry>
                                        <pt>FOR ('<varname>value</varname>')</pt>
                                        <pd>通过声明一个落在分区边界说明中的值来指定一个分区。如果用<codeph>FOR</codeph>声明的值匹配一个分区和它的一个子分区（例如，如果值是一个日期并且表先按月分区然后按日分区），那么<codeph>FOR</codeph>将在第一个找到匹配的层次上操作（例如，每月的分区）。如果用户的目的是在子分区上操作，则必须按如下的方式声明：<codeph>ALTER TABLE <varname>name</varname> ALTER
                                                  PARTITION FOR ('2016-10-01') DROP PARTITION FOR
                                                  ('2016-10-01');</codeph></pd>
                                </plentry>
                        </parml>
                </section>
                <section id="section5">
                        <title>注解</title>
                        <p><codeph>ALTER TABLE</codeph> 命令中指定的表名不能是一个表中的分区名。 </p>
                        <p>在修改或者删除作为Greenplum数据库分布键一部分的列时要特别小心，因为这可能会改变表的分布策略。.</p>
                        <p>Greenplum数据库当前不支持外键约束。对于要在Greenplum数据库中实施的唯一约束，表必须被哈希分布（不能用<codeph>DISTRIBUTED
                                        RANDOMLY</codeph>），并且所有的分布键列必须和唯一约束列中前部的列相同。</p>
								<p>增加<codeph>CHECK</codeph>或者<codeph>NOT NULL</codeph>约束要求扫描表以验证现有的行是否符合约束。</p>
                        <p>当使用<codeph>ADD COLUMN</codeph>添加列时，表中的所有现有行都使用该列的默认值初始化，如果未指定<codeph>DEFAULT</codeph>子句，则初始化为<codeph>NULL</codeph>。添加具有非空默认值的列或更改现有列的类型将需要重写整个表和索引。作为例外，如果<codeph>USING</codeph>子句不更改列的内容，并且旧类型可以强制转换为新类型或新类型不受限制的域，则不需要重写表，但是受影响列上的任何索引都必须仍在重建中。添加或删除系统<codeph>oid</codeph>列还需要重写整个表。对于大型表，表和/或索引的重建可能会花费大量时间；并且暂时需要多达两倍的磁盘空间。</p>
						<p>您可以在单个<codeph>ALTER TABLE</codeph>命令中指定多个更改，这些更改将在表上一次传递。</p>
                        <p><codeph>DROP COLUMN</codeph> 表单不会物理删除列，而只是使它对SQL操作不可见。表中随后的插入和更新操作将为该列存储一个空值。因此，删除列很快，但是不会立即减小表的磁盘大小，因为删除的列所占用的空间不会被回收。随着现有行的更新，空间将随着时间的推移而回收。但是，如果删除系统<codeph>oid</codeph>列，则表将立即被重写。</p>
                        <p> 要强制立即回收被删除的列占用的空间，您可以执行<codeph>ALTER TABLE</codeph>的一种形式来重写整个表。这将导致重建的每一行，并将删除的列替换为空值。</p>
                        <p> <codeph>ALTER TABLE</codeph>的重写形式不是MVCC安全的。在表重写之后，如果并发事务使用的是在重写发生之前拍摄的快照，则该表将对并发事务显示为空。有关更多详细信息，请参见<xref
                                        href="https://www.postgreql.org/docs/9.4/mvcc-caveats.html"
                                        scope="external" format="html">MVCC Caveats</xref> 。</p>
                        <p><codeph>SET DATA TYPE</codeph>的<codeph>USING</codeph>选项实际上可以指定涉及该行的旧值的任何表达式。也就是说，它可以引用其他列以及要转换的列。这允许使用<codeph>SET DATA TYPE</codeph>语法完成非常通用的转换。由于具有这种灵活性，因此<codeph>USING</codeph>表达式不会应用于列的默认值（如果有）；结果可能不是默认值所需的常量表达式。这意味着当没有从旧类型到新类型的隐式或赋值转换时，即使提供了<codeph>USING</codeph>子句，<codeph>SET DATA TYPE</codeph>也可能无法转换默认值。在这种情况下，请使用<codeph>DROP DEFAULT</codeph>删除默认值，执行<codeph>ALTER TYPE</codeph>，然后使用<codeph>SET
                                        DEFAULT</codeph>添加合适的新默认值。类似的考虑适用于涉及该列的索引和约束。</p>
                        <p>如果表已分区或具有任何后代表，则不允许在父表中添加，重命名或更改列的类型或重命名继承的约束，而无需对后代进行相同的操作。这样可以确保后代始终具有与父代匹配的列。 </p>
                        <p>要查看分区表的结构，可以使用视图<codeph><xref
                                                href="../system_catalogs/pg_partitions.xml"
                                                type="topic" format="dita"/></codeph>。该视图可以帮助您识别您可能要更改的特定分区。</p>
                        <p>仅当后代不从任何其他父级继承该列并且从未对该列进行独立定义时，递归<codeph>DROP
                                        COLUMN</codeph>操作才会删除后代表的列。非递归<codeph>DROP
                                        COLUMN</codeph>（仅<codeph>ALTER TABLE ONLY ... DROP
                                        COLUMN</codeph>）从不删除任何后代列，而是将它们标记为独立定义而不是继承。</p>
                        <p><codeph>TRIGGER</codeph>, <codeph>CLUSTER</codeph>,
                                        <codeph>OWNER</codeph>和 <codeph>TABLESPACE</codeph>操作永远不会递归到后代表。也就是说，它们始终像指定<codeph>ONLY</codeph>那样起作用。仅对未标记为<codeph>NO INHERIT</codeph>的<codeph>CHECK</codeph>约束重复添加约束。</p>
                        <p>如果包含已被交换以使用外部表的叶子分区的分区表上的数据没有更改，则支持这些<codeph>ALTER PARTITION</codeph>操作。否则，将返回错误。<ul id="ul_hcw_mrn_qs">
                                        <li>Adding or dropping a column.</li>
                                        <li>Changing the data type of column.</li>
                                </ul></p>
                        <p>分区表不支持这些<codeph>ALTER PARTITION</codeph>操作，该分区表包含已被交换以使用外部表的叶子分区：<ul id="ul_edw_mrn_qs">
                                        <li>Setting a subpartition template.</li>
                                        <li>Altering the partition properties.</li>
                                        <li>Creating a default partition.</li>
                                        <li>Setting a distribution policy.</li>
                                        <li>Setting or dropping a <codeph>NOT NULL</codeph>
                                                constraint of column.</li>
                                        <li>Adding or dropping constraints.</li>
                                        <li>Splitting an external partition.</li>
                                </ul></p>
                        <p>不允许更改系统目录表的任何部分。</p>
                </section>
                <section id="section6">
                        <title>Examples</title>
                        <p>向列中添加列：</p>
                        <codeblock>ALTER TABLE distributors ADD COLUMN address varchar(30);</codeblock>
                        <p>重命名现有列：</p>
                        <codeblock>ALTER TABLE distributors RENAME COLUMN address TO city;</codeblock>
                        <p>重命名现有表：</p>
                        <codeblock>ALTER TABLE distributors RENAME TO suppliers;</codeblock>
                        <p>向列添加非空约束：</p>
						<codeblock>ALTER TABLE distributors ALTER COLUMN street SET NOT NULL;</codeblock>
                        <p>重命名现有约束：</p>
                        <codeblock>ALTER TABLE distributors RENAME CONSTRAINT zipchk TO zip_check;</codeblock>
                        <p>向表及其所有子级添加检查约束：</p>
                        <codeblock>ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK 
(char_length(zipcode) = 5);</codeblock>
                        <p>要将检查约束仅添加到表而不是其子表，请执行以下操作：</p>
                        <codeblock>ALTER TABLE distributors ADD CONSTRAINT zipchk CHECK (char_length(zipcode) = 5) NO INHERIT;</codeblock>
                        <p>（检查约束也不会被将来的子代继承。）</p>

                        <p>从表及其所有子级中删除检查约束：</p>
                        <codeblock>ALTER TABLE distributors DROP CONSTRAINT zipchk;</codeblock>
                        <p>仅从一个表中删除检查约束：</p>
                        <codeblock>ALTER TABLE ONLY distributors DROP CONSTRAINT zipchk;</codeblock>
                        <p>（对于任何继承<codeph>distributors</codeph>的子表，检查约束仍然存在。）</p>
                        <p>将表移动到不同的模式：</p>
                        <codeblock>ALTER TABLE myschema.distributors SET SCHEMA yourschema;</codeblock>
                        <p>将表的分发策略更改为已复制：</p>
                        <codeblock>ALTER TABLE myschema.distributors SET DISTRIBUTED REPLICATED;</codeblock>
                        <p>将新分区添加到分区表：</p>
                        <codeblock>ALTER TABLE sales ADD PARTITION 
            START (date '2017-02-01') INCLUSIVE 
            END (date '2017-03-01') EXCLUSIVE;</codeblock>
                        <p>向现有分区设计添加默认分区：</p>
                        <codeblock>ALTER TABLE sales ADD DEFAULT PARTITION other;</codeblock>
                        <p>重命名分区：</p>
                        <codeblock>ALTER TABLE sales RENAME PARTITION FOR ('2016-01-01') TO 
jan08;</codeblock>
                        <p>删除范围序列中的第一个（最旧的）分区：</p>
                        <codeblock>ALTER TABLE sales DROP PARTITION FOR (RANK(1));</codeblock>
                        <p>将表交换到用户的分区设计中：</p>
                        <codeblock>ALTER TABLE sales EXCHANGE PARTITION FOR ('2016-01-01') WITH 
TABLE jan08;</codeblock>
                        <p>拆分默认分区(现有的默认分区名称<codeph>other</codeph>)为2017年1月添加新的每月分区：</p>
                        <codeblock>ALTER TABLE sales SPLIT DEFAULT PARTITION 
START ('2017-01-01') INCLUSIVE 
END ('2017-02-01') EXCLUSIVE 
INTO (PARTITION jan09, PARTITION other);</codeblock>
                        <p>将每月分区分成两个分区，第一个分区包含日期1月1日至15日，第二个分区包含日期1月16日至31日：</p>
                        <codeblock>ALTER TABLE sales SPLIT PARTITION FOR ('2016-01-01')
AT ('2016-01-16')
INTO (PARTITION jan081to15, PARTITION jan0816to31);</codeblock>
                        <p>要重新创建主键约束，而在重建索引时不阻止更新：</p>
                        <codeblock>CREATE UNIQUE INDEX CONCURRENTLY dist_id_temp_idx ON distributors (dist_id);
ALTER TABLE distributors DROP CONSTRAINT distributors_pkey,
ADD CONSTRAINT distributors_pkey PRIMARY KEY USING INDEX dist_id_temp_idx;
                        </codeblock>
                </section>
                <section id="section7">
                        <title>兼容性</title>
                        <p><codeph>ADD</codeph> (不包含 <codeph>USING INDEX</codeph>),
                                        <codeph>DROP</codeph>, <codeph>SET DEFAULT</codeph>和
                                        <codeph>SET DATA TYPE</codeph> (不包含
                                        <codeph>USING</codeph>) 符合SQL标准。 其他形式是SQL标准的Greenplum数据库扩展。 同样，在单个<codeph>ALTER TABLE</codeph>命令中指定多个操纵的功能也是一种扩展。</p>
                        <p><codeph>ALTER TABLE DROP COLUMN</codeph>可用于删除表的唯一列，而保留零列表。 这是SQL的扩展，不允许使用零列表。</p>
                </section>
                <section id="section8">
                        <title>另见</title>
                        <p><codeph><xref href="./CREATE_TABLE.xml#topic1" type="topic" format="dita"
                                        /></codeph>, <codeph><xref href="./DROP_TABLE.xml#topic1"
                                                type="topic" format="dita"/></codeph></p>
                </section>
        </body>
</topic>
