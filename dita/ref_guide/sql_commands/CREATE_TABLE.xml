<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic
        PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1">
    <title id="cd20941">CREATE TABLE</title>
    <body>
        <p id="sql_command_desc">定义一个新表。</p>
        <note type="note">引用完整性语法（外键约束）被接受但未强制执行。
        </note>
        <section id="section2">
            <title>概要</title>
            <codeblock id="sql_command_synopsis">CREATE [ [GLOBAL | LOCAL] {TEMPORARY | TEMP } | UNLOGGED] TABLE [IF NOT EXISTS]
    <varname>table_name</varname> (
    [ { <varname>column_name</varname> <varname>data_type</varname> [ COLLATE <varname>collation</varname> ] [<varname>column_constraint</varname> [ ... ] ]
[ ENCODING ( <varname>storage_directive</varname> [, ...] ) ]
    | <varname>table_constraint</varname>
    | LIKE <varname>source_table</varname> [ <varname>like_option</varname> ... ] }
    | [ <varname>column_reference_storage_directive</varname> [, ...]
    [, ... ]
] )
[ INHERITS ( <varname>parent_table</varname> [, ... ] ) ]
[ WITH ( <varname>storage_parameter</varname> [=<varname>value</varname>] [, ... ] ) 
       | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <varname>tablespace_name</varname> ]
[ DISTRIBUTED BY (<varname>column</varname> [<varname>opclass</varname>], [ ... ] ) 
       | DISTRIBUTED RANDOMLY | DISTRIBUTED REPLICATED ]
[ PARTITION BY <varname>partition_type</varname> (<varname>column</varname>)
       [ SUBPARTITION BY <varname>partition_type</varname> (<varname>column</varname>) ] 
          [ SUBPARTITION TEMPLATE ( <varname>template_spec</varname> ) ]
       [...]
    ( <varname>partition_spec</varname> ) 
        | [ SUBPARTITION BY <varname>partition_type</varname> (<varname>column</varname>) ]
          [...]
    ( <varname>partition_spec</varname>
      [ ( <varname>subpartition_spec</varname>
           [(...)] 
         ) ] 
    ) ]

CREATE [ [GLOBAL | LOCAL] {TEMPORARY | TEMP} | UNLOGGED ] TABLE [IF NOT EXISTS] 
   <varname>table_name</varname>
    OF <varname>type_name</varname> [ (
  { <varname>column_name</varname> WITH OPTIONS [ <varname>column_constraint</varname> [ ... ] ]
    | <varname>table_constraint</varname> } 
    [, ... ]
) ]
[ WITH ( <varname>storage_parameter</varname> [=<varname>value</varname>] [, ... ] ) | WITH OIDS | WITHOUT OIDS ]
[ ON COMMIT { PRESERVE ROWS | DELETE ROWS | DROP } ]
[ TABLESPACE <varname>tablespace_name</varname> ]
</codeblock>
            <p>其中<varname>column_constraint</varname>是：
            </p>
            <codeblock>[ CONSTRAINT <varname>constraint_name</varname>]
{ NOT NULL
  | NULL
  | CHECK ( <varname>expression</varname> ) [ NO INHERIT ]
  | DEFAULT <varname>default_expr</varname>
  | UNIQUE <varname>index_parameters</varname>
  | PRIMARY KEY <varname>index_parameters</varname>
  | REFERENCES <varname>reftable</varname> [ ( refcolumn ) ] 
      [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]  
      [ ON DELETE <varname>key_action</varname> ] [ ON UPDATE <varname>key_action</varname> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</codeblock>
      <p><varname>table_constraint</varname>是：</p>
      <codeblock>[ CONSTRAINT <varname>constraint_name</varname> ]
{ CHECK ( <varname>expression</varname> ) [ NO INHERIT ]
  | UNIQUE ( <varname>column_name</varname> [, ... ] ) <varname>index_parameters</varname>
  | PRIMARY KEY ( <varname>column_name</varname> [, ... ] ) <varname>index_parameters</varname>
  | FOREIGN KEY ( <varname>column_name</varname> [, ... ] ) 
      REFERENCES <varname>reftable</varname> [ ( <varname>refcolumn</varname> [, ... ] ) ]
      [ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ] 
      [ ON DELETE <varname>key_action</varname> ] [ ON UPDATE <varname>key_action</varname> ] }
[ DEFERRABLE | NOT DEFERRABLE ] [ INITIALLY DEFERRED | INITIALLY IMMEDIATE ]</codeblock>
            <p><i>like_option</i>是：
                <codeblock>{INCLUDING|EXCLUDING} {DEFAULTS|CONSTRAINTS|INDEXES|STORAGE|COMMENTS|ALL}</codeblock>
            </p>
            <p><codeph>UNIQUE</codeph>和<codeph>PRIMARY KEY</codeph>中的<varname>index_parameters</varname>约束为：
            </p>
            <codeblock>[ WITH ( <varname>storage_parameter</varname> [=<varname>value</varname>] [, ... ] ) ]
[ USING INDEX TABLESPACE <varname>tablespace_name</varname> ]</codeblock>
            <p>列的<varname>storage_directive</varname>是：
            </p>
            <codeblock>compresstype={ZLIB|ZSTD|QUICKLZ|RLE_TYPE|NONE}
    [compresslevel={0-9}]
    [blocksize={8192-2097152} ]</codeblock>
      <p>表的<varname>storage_parameter</varname>是：</p>
      <codeblock>   appendoptimized={TRUE|FALSE}
   blocksize={8192-2097152}
   orientation={COLUMN|ROW}
   checksum={TRUE|FALSE}
   compresstype={ZLIB|ZSTD|QUICKLZ|RLE_TYPE|NONE}
   compresslevel={0-9}
   fillfactor={10-100}
   oids[=TRUE|FALSE]</codeblock>
            <p><varname>key_action</varname>是：</p>
            <codeblock>    ON DELETE
   | ON UPDATE
   | NO ACTION
   | RESTRICT
   | CASCADE
   | SET NULL
   | SET DEFAULT</codeblock>
            <p><varname>partition_type</varname>是：
            </p>
            <codeblock>    LIST | RANGE</codeblock>
            <p><varname>partition_specification</varname>是：
            </p>
            <codeblock><varname>partition_element</varname> [, ...]</codeblock>
            <p><varname>partition_element</varname>是：
            </p>
            <codeblock>   DEFAULT PARTITION
                <varname>name</varname>
   | [PARTITION <varname>name</varname>] VALUES (<varname>list_value</varname> [,...] )
   | [PARTITION <varname>name</varname>]
      START ([<varname>datatype</varname>] '<varname>start_value</varname>') [INCLUSIVE | EXCLUSIVE]
      [ END ([<varname>datatype</varname>] '<varname>end_value</varname>') [INCLUSIVE | EXCLUSIVE] ]
      [ EVERY ([<varname>datatype</varname>] [<varname>number |</varname>INTERVAL] '<varname>interval_value</varname>') ]
   | [PARTITION <varname>name</varname>]
      END ([<varname>datatype</varname>] '<varname>end_value</varname>') [INCLUSIVE | EXCLUSIVE]
      [ EVERY ([<varname>datatype</varname>] [<varname>number |</varname>INTERVAL] '<varname>interval_value</varname>') ]
[ WITH ( <varname>partition_storage_parameter</varname>=<varname>value</varname> [, ... ] ) ]
[ <varname>column_reference_storage_directive</varname> [, ...] ]
[ TABLESPACE <varname>tablespace</varname> ]</codeblock>
            <p>其中<varname>subpartition_spec</varname>或<varname>template_spec</varname>是：
            </p>
            <codeblock><varname>subpartition_element</varname> [, ...]</codeblock>
            <p><varname>subpartition_element</varname>是：
            </p>
            <codeblock>   DEFAULT SUBPARTITION <varname>name</varname>
    | [SUBPARTITION <varname>name</varname>] VALUES (<varname>list_value</varname> [,...] )
    | [SUBPARTITION <varname>name</varname>]
       START ([<varname>datatype</varname>] '<varname>start_value</varname>') [INCLUSIVE | EXCLUSIVE]
       [ END ([<varname>datatype</varname>] '<varname>end_value</varname>') [INCLUSIVE | EXCLUSIVE] ]
       [ EVERY ([<varname>datatype</varname>] [<varname>number |</varname>INTERVAL] '<varname>interval_value</varname>') ]
    | [SUBPARTITION <varname>name</varname>]
       END ([<varname>datatype</varname>] '<varname>end_value</varname>') [INCLUSIVE | EXCLUSIVE]
       [ EVERY ([<varname>datatype</varname>] [<varname>number |</varname>INTERVAL] '<varname>interval_value</varname>') ]
[ WITH ( <varname>partition_storage_parameter</varname>=<varname>value</varname> [, ... ] ) ]
[ <varname>column_reference_storage_directive</varname> [, ...] ]
[ TABLESPACE <varname>tablespace</varname> ]</codeblock>
      <p>其中分区的<varname>storage_parameter</varname>是：</p>
      <codeblock>   appendoptimized={TRUE|FALSE}
   blocksize={8192-2097152}
   orientation={COLUMN|ROW}
   checksum={TRUE|FALSE}
   compresstype={ZLIB|ZSTD|QUICKLZ|RLE_TYPE|NONE}
   compresslevel={1-19}
   fillfactor={10-100}
   oids[=TRUE|FALSE]</codeblock>
        </section>
        <section id="section3">
            <title>描述</title>
            <p><codeph>CREATE TABLE</codeph>在当前数据库中创建一个最初为空的表。
                执行命令的用户拥有该表。
            </p>
            <p>为了能够创建表，您必须分别对所有列类型或<codeph>OF</codeph>子句中的类型具有<codeph>USAGE</codeph>特权。
            </p>
            <p>如果指定模式名称，Greenplum将在指定的模式中创建表。
                否则，Greenplum将在当前模式中创建表。
                临时表存在于特殊的模式中，因此在创建临时表时不能指定模式名称。
                表名称必须与同一模式中的任何其他表，外部表，序列，索引，视图或外部表的名称不同。
            </p>
            <p><codeph>CREATE TABLE</codeph>还会自动创建一个数据类型，该数据类型表示与表的一行相对应的复合类型。
                因此，表不能与同一模式中的任何现有数据类型具有相同的名称。
            </p>
            <p>可选的约束子句指定新行或更新行必须满足的条件才能成功执行插入或更新操作。
                约束是一个SQL对象，可以通过多种方式帮助定义表中的有效值集。
                约束适用于表，而不适用于分区。
                您不能将约束添加到分区或子分区。
            </p>
            <p>引用完整性约束（外键）被接受但不强制执行。
                该信息保留在系统catalog中，否则将被忽略。
            </p>
            <p>有两种定义约束的方法：表约束和列约束。
                列约束被定义为列定义的一部分。
                表约束定义不与特定列绑定，并且可以包含多个列。
                每个列约束也可以写为表约束。
                当约束仅影响一列时，使用列约束只是一种符号上的方便。
            </p>
            <p>创建表时，还有一个附加子句来声明Greenplum数据库分发策略。
                如果未提供<codeph>DISTRIBUTED BY</codeph>，<codeph>DISTRIBUTED RANDOMLY</codeph>或<codeph>DISTRIBUTED REPLICATED</codeph>子句，
                则Greenplum数据库将通过使用<codeph>PRIMARY KEY</codeph>（如果表具有一个）或表的第一列作为分发键，向该表分配哈希分发策略。
                几何或用户定义数据类型的列不符合Greenplum分布键列的要求。
                如果表中没有符合条件的数据类型的列，则将根据轮询或随机分布来分配行。
                为了确保数据在Greenplum数据库系统中的均匀分配，
                您希望选择一个对于每个记录都是唯一的分配键，或者如果不可能，则选择<codeph>DISTRIBUTED RANDOMLY</codeph>。
            </p>
            <p>如果提供了<codeph>DISTRIBUTED REPLICATED</codeph>子句，则Greenplum数据库会将表的所有行分配给Greenplum数据库系统中的所有segment。
                如果用户定义的函数必须在segment上执行，并且这些函数需要访问表的所有行，则可以使用此选项。
                复制函数还可以用于防止表的broadcast motions，从而提高查询性能。
                <codeph>DISTRIBUTED REPLICATED</codeph>子句不能与<codeph>PARTITION BY</codeph>子句或<codeph>INHERITS</codeph>子句一起使用。
                复制的表也不能被另一个表继承。
                隐藏的系统列（<codeph>ctid</codeph>，<codeph>cmin</codeph>，<codeph>cmax</codeph>，<codeph>xmin</codeph>，
                <codeph>xmax</codeph>和<codeph>gp_segment_id</codeph>）无法在复制表的用户查询中引用，因为它们没有单一的，无歧义的值。
            </p>
            <p>通过<codeph>PARTITION BY</codeph>子句，您可以将表分为多个子表（或部分），这些子表一起构成父表并共享其模式。
                尽管子表作为独立表存在，但是Greenplum数据库以重要方式限制了它们的使用。
                在内部，分区被实现为继承的一种特殊形式。
                每个子表分区都是根据不同的<codeph>CHECK</codeph>约束创建的，该约束根据一些定义条件限制表可以包含的数据。
                查询优化器还使用<codeph>CHECK</codeph>约束来确定要扫描哪些表分区以满足给定的查询谓词。
                这些分区约束由Greenplum数据库自动管理。
            </p>
        </section>
        <section id="section4">
            <title>参数</title>
            <parml>
                <plentry>
                    <pt>GLOBAL | LOCAL</pt>
                    <pd>提供这些关键字是为了实现SQL标准兼容性，但在Greenplum数据库中无效，并且已弃用。
                    </pd>
                </plentry>
                <plentry>
                    <pt>TEMPORARY | TEMP</pt>
                    <pd>如果指定，该表将被创建为临时表。
                        临时表在会话结束时或在当前事务结束时自动删除（请参见<codeph>ON COMMIT</codeph>）。
                        临时表存在时，具有相同名称的现有永久表在当前会话中不可见，除非使用模式限定名称引用它们。
                        在临时表上创建的所有索引也会自动成为临时索引。
                    </pd>
                </plentry>
                <plentry>
                    <pt>UNLOGGED</pt>
                    <pd>如果指定，该表将创建为未记录表。
                        写入未记录表的数据不会写入预写（WAL）日志，这使它们比普通表快得多。
                        但是，未记录表的内容不会复制到mirror实例。
                        同样，未记录的表也不是崩溃安全的。
                        segment实例崩溃或异常关闭后，该segment上未记录表的数据将被截断。
                        在未记录表上创建的所有索引也会自动成为未记录索引。
                    </pd>
                </plentry>
                <plentry>
                    <pt>
                        <varname>table_name</varname>
                    </pt>
                    <pd>要创建的新表的名称（可以由模式指定）。</pd>
                </plentry>
                <plentry>
                    <pt>OF <varname>type_name</varname>
                    </pt>
                    <pd>创建一个类型化的表，该表从指定的组合类型（名称可以由模式指定）获取其结构。
                        类型化的表与其类型相关联。
                        例如，如果删除了类型（使用<codeph>DROP TYPE ... CASCADE</codeph>），则将删除该表。
                    </pd>
                    <pd>当一个类型化的表被创建时，列的数据类型由底层的组合类型决定而没有在<codeph>CREATE TABLE</codeph>命令中直接指定。
                        但是<codeph>CREATE TABLE</codeph>命令可以对表增加默认值和约束，并且可以指定存储参数。
                    </pd>
                </plentry>
                <plentry>
                    <pt>
                        <varname>column_name</varname>
                    </pt>
                    <pd>要在新表中创建的列的名称。</pd>
                </plentry>
                <plentry>
                    <pt>
                        <varname>data_type</varname>
                    </pt>
                    <pd>列的数据类型。这可能包括数组说明符。</pd>
                    <pd>对于包含文本数据的表列，请指定数据类型<codeph>VARCHAR</codeph>或<codeph>TEXT</codeph>。
                        不建议指定数据类型<codeph>CHAR</codeph>。
                        在Greenplum数据库中，数据类型<codeph>VARCHAR</codeph>或<codeph>TEXT</codeph>处理作为有效字符添加到数据
                        （在最后一个非空格字符之后添加的空格字符）的填充，而数据类型<codeph>CHAR</codeph>不处理。
                        请参阅<xref href="#topic1/section5" format="dita"/>。
                    </pd>
                </plentry>
                <plentry>
                    <pt>COLLATE
                        <varname>collation</varname>
                    </pt>
                    <pd><codeph>COLLATE</codeph>子句为该列分配排序规则（该排序规则必须是可排序的数据类型）。
                        如果未指定，则使用列数据类型的默认排序规则。
                        <note>仅当查询中的所有列使用相同的排序规则时，GPORCA才支持排序规则。
                        如果查询中的列使用不同的排序规则，则Greenplum使用Postgres查询优化器。</note>
                    </pd>
                </plentry>
                <plentry>
                    <pt>DEFAULT
                        <varname>default_expr</varname>
                    </pt>
                    <pd><codeph>DEFAULT</codeph>子句为出现在其列定义中的列分配默认数据值。
                        该值是任何不带变量的表达式（不允许对当前表中的其他列进行子查询和交叉引用）。
                        默认表达式的数据类型必须与列的数据类型匹配。
                        默认表达式将在未为列指定值的任何插入操作中使用。
                        如果列没有默认值，则默认值为null。
                    </pd>
                </plentry>
                <plentry>
                    <pt>ENCODING ( <varname>storage_directive</varname> [, ...] )
                    </pt>
                    <pd>对于列，可选的<codeph>ENCODING</codeph>子句指定列数据的压缩类型和块大小。
                        有关<codeph>compresstype</codeph>，<codeph>compresslevel</codeph>和<codeph>blocksize</codeph>值，请参见<xref href="#topic1/with_storage" format="dita">storage_options</xref>。
                    </pd>
                    <pd>该子句仅对追加优化的，面向列的表有效。</pd>
                    <pd>列压缩设置从表级别继承到分区级别再到子分区级别。
                        最低级别的设置具有优先权。
                    </pd>
                </plentry>
                <plentry>
                    <pt>INHERITS ( parent_table [, …])</pt>
                    <pd>可选的<codeph>INHERITS</codeph>子句指定一个表列表，新表将从中自动继承所有列。
                        使用<codeph>INHERITS</codeph>将在新的子表及其父表之间创建持久关系。
                        对父级的模式修改通常也会传播到子级，默认情况下，子级表的数据包含在父级扫描中。
                    </pd>
                    <pd>在Greenplum数据库中，创建分区表时不使用<codeph>INHERITS</codeph>子句。
                        尽管在分区层次结构中使用了继承的概念，但是使用<codeph><xref href="#topic1/part_by" format="dita">PARTITION BY</xref></codeph>子句创建了分区表的继承结构。
                    </pd>
                    <pd>如果一个以上的父表中存在相同的列名，则将报告错误，除非每个父表中的列的数据类型都匹配。
                        如果没有冲突，则将重复的列合并以在新表中形成一个列。
                        如果新表的列名列表包含一个也被继承的列名，则数据类型必须同样与继承的列匹配，并且列定义将合并为一个。
                        如果新表显式指定了该列的默认值，则该默认值将覆盖该列的继承声明中的所有默认值。
                        否则，为该列指定默认值的所有父项都必须指定相同的默认值，否则将报告错误。
                    </pd>
                    <pd><codeph>CHECK</codeph>约束基本上以与列相同的方式合并：
                        如果多个父表或新表定义包含名称相同的约束，则这些约束必须全部具有相同的校验表达式，否则将报告错误。
                        具有相同名称和表达式的约束将合并为一个副本。
                        不会考虑在父级中标记为<codeph>NO INHERIT</codeph>的约束。
                        请注意，新表中未命名的<codeph>CHECK</codeph>约束将永远不会被合并，因为将始终为其选择唯一的名称。
                    </pd>
                    <pd>列<codeph>STORAGE</codeph>设置也会从父表中复制。
                    </pd>
                </plentry>
                <plentry>
                    <pt>LIKE
                        <varname>source_table</varname>
                        <varname>like_option</varname>
                        <codeph>...</codeph>]
                    </pt>
                    <pd><codeph>LIKE</codeph>子句指定一个表，新表将从该表中自动复制所有列名，其数据类型，非空约束和分发策略。
                        不会复制诸如追加优化或分区结构之类的存储属性。
                        与<codeph>INHERITS</codeph>不同，新表和原始表在创建完成后完全解耦。
                    </pd>
                    <pd>仅当指定<codeph>INCLUDING DEFAULTS</codeph>时，才会复制复制的列定义的默认表达式。
                        默认行为是排除默认表达式，导致新表中复制的列具有空默认值。
                    </pd>
                    <pd>非空约束始终会复制到新表中。
                        仅当指定<codeph>INCLUDING CONSTRAINTS</codeph>时，才会复制<codeph>CHECK</codeph>约束。
                        列约束和表约束之间没有区别。
                    </pd>
                    <pd>仅在指定<codeph>INCLUDING INDEXES</codeph>子句的情况下，才会在新表上创建原始表的索引，
                        <codeph>PRIMARY KEY</codeph>和<codeph>UNIQUE</codeph>约束。
                        不论原始名称如何命名，都会根据默认规则选择新索引和约束的名称。
                        （此行为避免了新索引可能出现的重复名称错误。）
                    </pd>
                    <pd>除非指定了<codeph>INCLUDING INDEXES</codeph>子句，否则不会在新表上创建原始表上的任何索引。
                    </pd>
                    <pd>仅当指定了<codeph>INCLUDING STORAGE</codeph>时，才会复制复制的列定义的<codeph>STORAGE</codeph>设置。
                        默认行为是排除<codeph>STORAGE</codeph>设置，导致新表中复制的列具有特定于类型的默认设置。
                    </pd>
                    <pd>仅当指定<codeph>INCLUDING COMMENTS</codeph>时，才会复制复制的列，约束和索引的注释。
                        默认行为是排除注释，导致新表中复制的列和约束没有注释。
                    </pd>
                    <pd>
                        <codeph>INCLUDING ALL</codeph>
                        是
                        <codeph>INCLUDING DEFAULTS INCLUDING CONSTRAINTS INCLUDING INDEXES
                            INCLUDING STORAGE INCLUDING COMMENTS</codeph>的缩写形式.
                    </pd>
                    <pd>请注意，与<codeph>INHERITS</codeph>不同，<codeph>LIKE</codeph>复制的列和约束不会与名称相似的列和约束合并。
                        如果显式指定了相同的名称，或者在另一个<codeph>LIKE</codeph>子句中指定了相同的名称，则将指示错误。
                    </pd>
                    <pd><codeph>LIKE</codeph>子句还可用于从视图，外部表或复合类型中复制列。
                        不适用的选项（例如，从视图<codeph>INCLUDING INDEXES</codeph>）将被忽略。
                    </pd>
                </plentry>
                <plentry>
                    <pt>CONSTRAINT
                        <varname>constraint_name</varname>
                    </pt>
                    <pd>列或表约束的可选名称。
                        如果违反了约束，那么约束名称将出现在错误消息中，因此可以使用约束名称（例如列必须为正）来将有用的约束信息传达给客户端应用程序。
                        （需要双引号指定包含空格的约束名称。）如果未指定约束名称，则系统将生成一个名称。
                        <note type="note">指定的<varname>constraint_name</varname>用于约束，但系统生成的唯一名称用于索引名。
                            在某些以前的版本中，提供的名称同时用于约束名称和索引名称。
                        </note>
                    </pd>
                </plentry>
                <plentry>
                    <pt>NULL | NOT NULL</pt>
                    <pd>指定是否允许该列包含空值。默认值为<codeph>NULL</codeph>。
                    </pd>
                </plentry>
                <plentry>
                    <pt>CHECK (<varname>expression</varname>) [ NO INHERIT ]
                    </pt>
                    <pd><codeph>CHECK</codeph>子句指定一个生成布尔结果的表达式，新的或更新的行必须满足才能使插入或更新操作成功。
                        计算为<codeph>TRUE</codeph>或<codeph>UNKNOWN</codeph>的表达式会成功。
                        如果插入或更新操作的任何行都产生<codeph>FALSE</codeph>结果，则会引发错误异常，并且插入或更新不会更改数据库。
                        指定为列约束的检查约束应仅引用该列的值，而出现在表约束中的表达式可以引用多个列。
                    </pd>
                    <pd>标有<codeph>NO INHERIT</codeph>的约束不会传播到子表。
                    </pd>
                    <pd>当前，<codeph>CHECK</codeph>表达式不能包含子查询，也不能引用当前行的列以外的变量。
                    </pd>
                </plentry>
                <plentry>
                    <pt>UNIQUE ( <varname>column_constraint</varname> )
                    </pt>
                    <pt>UNIQUE ( <varname>column_name</varname> [, ... ] ) (
                        <varname>table_constraint</varname>
                        )
                    </pt>
                    <pd><codeph>UNIQUE</codeph>约束指定表的一组一个或多个列只能包含唯一值。
                        唯一表约束的行为与列约束的行为相同，但具有跨多个列的附加功能。
                        出于唯一约束的目的，空值不视为相等。
                        唯一的列必须包含Greenplum分布键的所有列。
                        此外，如果表已分区，则<codeph>&lt;key&gt;</codeph>必须包含分区键中的所有列。
                        请注意，分区表中的<codeph>&lt;key&gt;</codeph>约束与简单的<codeph>UNIQUE INDEX</codeph>不同。
                    </pd>
                    <pd>有关唯一约束管理和限制的信息，请参见<xref href="#topic1/section5" format="dita"/>。
                    </pd>
                </plentry>
                <plentry>
                    <pt>PRIMARY KEY ( <varname>column constraint</varname> )
                    </pt>
                    <pt>PRIMARY KEY ( <varname>column_name</varname> [, ... ] ) ( <varname>table
                        constraint
                    </varname> )
                    </pt>
                    <pd><codeph>PRIMARY KEY</codeph>约束指定表的一列或多列只能包含唯一（非重复），非null值。
                        只能为一个表指定一个主键，无论是作为列约束还是表约束。
                    </pd>
                    <pd>要使一个表具有主键，它必须是哈希分布的（不是随机分布的），并且主键（唯一的列）必须包含Greenplum分布键的所有列。
                        此外，如果表已分区，则<codeph>&lt;key&gt;</codeph>必须包含分区键中的所有列。
                        请注意，分区表中的<codeph>&lt;key&gt;</codeph>约束与简单的<codeph>UNIQUE INDEX</codeph>不同。
                    </pd>
                    <pd><codeph>PRIMARY KEY</codeph>强制执行与<codeph>UNIQUE</codeph>和<codeph>NOT NULL</codeph>相同的组合数据约束，
                        但是将一组列标识为主键也可以提供有关模式设计的元数据，因为主键标识其他表可以依赖这一个列集合作为行的唯一标识符。
                    </pd>
                    <pd>有关主键管理和限制的信息，请参阅<xref href="#topic1/section5" format="dita"/>。
                    </pd>
                </plentry>
                <plentry>
                    <pt>REFERENCES <varname>reftable</varname> [ ( <varname>refcolumn</varname> ) ]
                    </pt>
                    <pt>[ MATCH FULL | MATCH PARTIAL | MATCH SIMPLE ]</pt>
                    <pt>[ON DELETE | ON UPDATE] [<varname>key_action</varname>]
                    </pt>
                    <pt>FOREIGN KEY (<varname>column_name</varname> [, ...])
                    </pt>
                    <pd><codeph>REFERENCES</codeph>和<codeph>FOREIGN KEY</codeph>子句指定引用完整性约束（外键约束）。
                        Greenplum接受PostgreSQL语法中指定的参照完整性约束，但不强制执行。
                        有关引用完整性约束的信息，请参见PostgreSQL文档。
                    </pd>
                </plentry>
                <plentry>
                    <pt>DEFERRABLE</pt>
                    <pt>NOT DEFERRABLE</pt>
                    <pd><codeph>[NOT] DEFERRABLE</codeph>子句控制约束是否可以被推迟。
                        一个不可推迟的约束将在每个命令后立即进行检查。
                        可以推迟检查约束，直到事务结束（使用<xref href="SET_CONSTRAINTS.xml#topic1"><codeph>SET CONSTRAINTS</codeph></xref>命令）。
                        默认值是<codeph>NOT DEFERRABLE</codeph>。
                        当前，只有<codeph>UNIQUE</codeph>和<codeph>PRIMARY KEY</codeph>约束是可推迟的。
                        <codeph>NOT NULL</codeph>和<codeph>CHECK</codeph>约束不可延迟。
                        <codeph>REFERENCES</codeph>（外键）约束接受此子句，但不强制执行。
                    </pd>
                </plentry>
                <plentry>
                    <pt>INITIALLY IMMEDIATE</pt>
                    <pt>INITIALLY DEFERRED</pt>
                    <pd>如果约束是可延迟的，则此子句指定检查约束的默认时间。
                        如果该约束是<codeph>INITIALLY IMMEDIATE</codeph>，则在每个语句之后对其进行检查。
                        这是默认值。
                        如果约束是<codeph>INITIALLY DEFERRED</codeph>，则仅在事务结束时进行检查。
                        可以使用<codeph>SET CONSTRAINTS</codeph>命令更改约束检查时间。
                    </pd>
                </plentry>
                <plentry id="with_storage">
                    <pt>WITH ( <varname>storage_parameter=value</varname> )
                    </pt>
                    <pd><codeph>WITH</codeph>子句可以为表以及与<codeph>UNIQUE</codeph>或<codeph>PRIMARY</codeph>约束关联的索引指定存储参数。
                        请注意，您还可以通过在分区规范中声明<codeph>WITH</codeph>子句来在特定分区或子分区上设置存储参数。
                        最低级别的设置具有优先权。
                    </pd>
                    <pd>某些表存储选项的默认值可以使用服务器配置参数<codeph>gp_default_storage_options</codeph>指定。
                        有关设置默认存储选项的信息，请参阅<xref href="#topic1/section5" format="dita"/>。
                    </pd>
                    <pd>可以使用以下存储选项：</pd>
                    <pd>
                        <b>appendoptimized</b>
                        — 设置为<codeph>TRUE</codeph>可将表创建为追加优化的表。
                        如果为<codeph>FALSE</codeph>或未声明，则将表创建为常规堆存储表。
                    </pd>
                    <pd>
                        <b>blocksize</b>
                        — 设置为表中每个块的大小（以字节为单位）。
                        <codeph>blocksize</codeph>必须介于8192和2097152字节之间，并且是8192的倍数。默认值为32768。
                    </pd>
                    <pd>
                        <b>orientation</b>
                        — 设置为<codeph>column</codeph>以用于列式存储，或设置为<codeph>row</codeph>（默认）以用于行式存储。
                        仅当<codeph>appendoptimized=TRUE</codeph>时，此选项才有效。堆存储表只能是面向行的。
                    </pd>
                    <pd>
                        <b>checksum</b>
                        — 此选项仅对追加优化的表（<codeph>appendoptimized=TRUE</codeph>）有效。
                        值<codeph>TRUE</codeph>是默认值，并为追加优化表启用CRC校验和验证。
                        校验和是在块创建期间计算的，并存储在磁盘上。
                        在块读取期间执行校验和验证。
                        如果在读取期间计算出的校验和与存储的校验和不匹配，则事务中止。
                        如果将值设置为<codeph>FALSE</codeph>以禁用校验和验证，将不会执行检查表数据是否存在磁盘损坏的操作。
                    </pd>
                    <pd>
                        <b>compresstype</b>
                        — 设置为<codeph>ZLIB</codeph>（默认值），<codeph>ZSTD</codeph>，<codeph>RLE_TYPE</codeph>或<codeph>QUICKLZ</codeph><sup>1</sup>以指定使用的压缩类型。
                        值<codeph>NONE</codeph>禁用压缩。
                        Zstd提供速度或良好的压缩率，可通过<codeph>compresslevel</codeph>选项进行调整。
                        提供QuickLZ和zlib是为了向后兼容。
                        在通常的工作负载上，Zstd的性能优于这些压缩类型。
                        仅当<codeph>appendoptimized=TRUE</codeph>时，<codeph>compresstype</codeph>选项才有效。
                        <p>
                            <note type="note">注意：<sup>1</sup>QuickLZ压缩仅在商业版本的Pivotal Greenplum数据库中可用。
                            </note>
                        </p>
                        <p>仅当指定了<codeph>orientation</codeph>=<codeph>column</codeph>时才支持值<codeph>RLE_TYPE</codeph>，它启用游程编码（RLE）压缩算法。
                            当相同的数据值出现在许多连续的行中时，RLE的压缩数据比Zstd，zlib或QuickLZ压缩算法更好。
                        </p>
                        <p>对于<codeph>BIGINT</codeph>，<codeph>INTEGER</codeph>，<codeph>DATE</codeph>，
                            <codeph>TIME</codeph>或<codeph>TIMESTAMP</codeph>类型的列，如果将<codeph>compresstype</codeph>选项设置为<codeph>RLE_TYPE</codeph>压缩，则还将应用增量压缩。
                            增量压缩算法基于连续行中列值之间的增量，旨在改善按排序顺序加载数据或将压缩应用于按排序顺序的列数据时的压缩。
                        </p>
                        <p>有关使用表压缩的信息，请参阅<cite>Greenplum数据库管理员指南</cite>中的“选择表存储模型”。
                        </p>
                    </pd>
                    <pd>
                        <b>compresslevel</b>
                        — 对于追加优化表的Zstd压缩，请将其设置为1（最快压缩）到19（最高压缩率）之间的整数值。
                        对于zlib压缩，有效范围是1到9。QuickLZ压缩级别只能设置为1。
                        如果未声明，则默认值为1。
                        对于<codeph>RLE_TYPE</codeph>，压缩级别可以是1（最快压缩）到4（最高压缩率）之间的整数值。
                    </pd>
                    <pd>仅当<codeph>appendoptimized=TRUE</codeph>时，<codeph>compresslevel</codeph>选项才有效。
                    </pd>
                    <pd>
                        <b>fillfactor</b>
                        — 有关此索引存储参数的更多信息，请参见<codeph><xref href="CREATE_INDEX.xml#topic1" type="topic" format="dita"/></codeph>。
                    </pd>
                    <pd>
                        <b>oids</b>
                        — 设置为<codeph>oids=FALSE</codeph>（默认值），以便不为行分配对象标识符。
                        Greenplum强烈建议您在创建表时不要启用OIDS。
                        在大型表上（例如典型的Greenplum数据库系统中的表），对表行使用OID可能会导致32位OID计数器的折回。
                        一旦计数器回绕，就不能再认为OID是唯一的，这不仅使它们对用户应用程序无用，
                        而且还会在Greenplum数据库系统catalog表中引起问题。
                        此外，从表中排除OID会使表每行存储在磁盘上所需的空间减少了每行4个字节，从而略微提高了性能。
                        分区表或追加优化的面向列的表上不允许使用OIDS。
                    </pd>
                </plentry>
                <plentry>
                    <pt>WITH OIDS</pt>
                    <pt>WITHOUT OIDS</pt>
                    <pd>它们是分别等同于<codeph>WITH (OIDS)</codeph>和<codeph>WITH (OIDS=FALSE)</codeph>的过时语法。
                        如果希望同时提供OIDS设置和存储参数，则必须使用<codeph>WITH ( ... )</codeph>语法；往上看。
                        Greenplum强烈建议您在创建表时不要启用OIDS。
                        有关使用<b>oids</b>的更多信息，请参见<b>oids</b>参数说明。
                    </pd>
                </plentry>
                <plentry>
                    <pt>ON COMMIT</pt>
                    <pd>可以使用<codeph>ON COMMIT</codeph>控制事务块末尾的临时表的行为。
                        这三个选项是：</pd>
                    <pd>
                        <b>PRESERVE ROWS</b>
                        - 临时表的事务结束时不会采取任何特殊操作。这是默认行为。
                    </pd>
                    <pd>
                        <b>DELETE ROWS</b>
                        - 临时表中的所有行将在每个事务块的末尾删除。
                        本质上，每次提交都会自动执行一次<codeph>TRUNCATE</codeph>。
                    </pd>
                    <pd>
                        <b>DROP</b>
                        - 临时表将在当前事务块的末尾删除。
                    </pd>
                </plentry>
                <plentry>
                    <pt>TABLESPACE
                        <varname>tablespace</varname>
                    </pt>
                    <pd>要在其中创建新表的表空间的名称。如果未指定，则使用数据库的默认表空间。
                    </pd>
                </plentry>
                <plentry>
                    <pt>USING INDEX TABLESPACE
                        <varname>tablespace</varname>
                    </pt>
                    <pd>该子句允许选择将在其中创建与<codeph>UNIQUE</codeph>或<codeph>PRIMARY KEY</codeph>约束关联的索引的表空间。
                        如果未指定，则使用数据库的默认表空间。
                    </pd>
                </plentry>
                <plentry>
                    <pt>DISTRIBUTED BY (<varname>column</varname> [<varname>opclass</varname>], [ ... ] )
                    </pt>
                    <pt>DISTRIBUTED RANDOMLY</pt>
                    <pt>DISTRIBUTED REPLICATED</pt>
                    <pd>用于声明表的Greenplum数据库分布策略。
                        <codeph>DISTRIBUTED BY</codeph>使用具有一个或多个声明为分布键的列的哈希分布。
                        为了获得最均匀的数据分配，分布键应为表的主键或唯一列（或一组列）。
                        如果无法做到这一点，则可以选择<codeph>DISTRIBUTED RANDOMLY</codeph>，它将数据轮询发送到segment实例。
                        此外，可以指定运算符类<codeph>opclass</codeph>，以使用非默认哈希函数。
                    </pd>
                    <pd>如果在创建表时未指定<cmdname>DISTRIBUTED BY</cmdname>子句，
                        则Greenplum数据库服务器配置参数<codeph>gp_create_table_random_default_distribution</codeph>将控制表默认分布策略。
                        如果未指定分布策略，Greenplum数据库将遵循以下规则来创建表。
                        <p>如果参数的值是<codeph>off</codeph>（默认值），则Greenplum数据库根据以下命令选择表分布键：
                            <ul id="ul_rjb_gty_qfb">
                                <li>如果指定了<codeph>LIKE</codeph>或<codeph>INHERITS</codeph>子句，则Greenplum从源表或父表复制分布键。
                                </li>
                                <li>如果指定了<codeph>PRIMARY KEY</codeph>或<codeph>UNIQUE</codeph>约束，则Greenplum选择所有键列中最大的子集作为分布键。
                                </li>
                                <li>如果既未指定约束，也未指定<codeph>LIKE</codeph>或<codeph>INHERITS</codeph>子句，则Greenplum选择第一个合适的列作为分布键。
                                    （具有几何或用户定义数据类型的列不符合作为Greenplum分布键列的条件。）
                                </li>
                            </ul>
                        </p>
                        <p>如果参数的值设置为<codeph>on</codeph>，则Greenplum数据库遵循以下规则：
                            <ul id="ul_tbr_5kq_kq">
                                <li>如果未指定<cmdname>PRIMARY KEY</cmdname>或<cmdname>UNIQUE</cmdname>列，
                                    则表的分布是随机的（<cmdname>DISTRIBUTED RANDOMLY</cmdname>）。
                                    即使表创建命令包含<cmdname>LIKE</cmdname>或<cmdname>INHERITS</cmdname>子句，表分布也是随机的。
                                </li>
                                <li>如果指定了<cmdname>PRIMARY KEY</cmdname>或<cmdname>UNIQUE</cmdname>列，则还必须指定<cmdname>DISTRIBUTED BY</cmdname>子句。
                                    如果在表创建命令中未指定<cmdname>DISTRIBUTED BY</cmdname>子句，则该命令将失败。
                                </li>
                            </ul>
                        </p>
                    </pd>
                    <pd>有关设置默认表分布策略的更多信息，
                        请参见<xref href="../config_params/guc-list.xml#gp_create_table_random_default_distribution" type="section" format="dita"><codeph>gp_create_table_random_default_distribution</codeph></xref>。
                    </pd>
                    <pd><codeph>DISTRIBUTED REPLICATED</codeph>子句将整个表复制到所有Greenplum数据库segment实例。
                        当函数需要访问表中的所有行或需要通过阻止broadcast motion来提高查询性能时，必须在segment上执行用户定义的函数时可以使用它。
                    </pd>
                </plentry>
                <plentry id="part_by">
                    <pt>PARTITION BY</pt>
                    <pd>声明用于对表进行分区的一列或多列。</pd>
                    <pd>创建分区表时，Greenplum数据库使用指定的表名创建根分区表（根分区）。
                        Greenplum数据库还会根据您指定的分区选项创建表，子表的层次结构，这些表是子分区。
                        Greenplum数据库<i>pg_partition</i>*系统视图包含有关子分区表的信息。
                    </pd>
                    <pd>对于每个分区级别（表的每个层次结构级别），一个分区表最多可以有32,767个分区。
                    </pd>
                    <pd>
                        <note>Greenplum数据库将分区表数据存储在叶子表中，叶子表是子表层次结构中的最低级表，供分区表使用。
                        </note>
                    </pd>
                    <pd>
                        <parml>
                            <plentry>
                                <pt>
                                    <varname>partition_type</varname>
                                </pt>
                                <pd>声明分区类型：<codeph>LIST</codeph>（值列表）或<codeph>RANGE</codeph>（数字或日期范围）。
                                </pd>
                            </plentry>
                            <plentry>
                                <pt>
                                    <varname>partition_specification</varname>
                                </pt>
                                <pd>声明要创建的各个分区。
                                    可以单独定义每个分区，或者对于范围分区，可以使用<codeph>EVERY</codeph>子句（带有<codeph>START</codeph>和可选<codeph>END</codeph>子句）来定义用于创建单个分区的增量模式。
                                </pd>
                                <pd>
                                    <b>
                                        <codeph>DEFAULT PARTITION
                                            <varname>name</varname>
                                        </codeph>
                                    </b>
                                    — 声明默认分区。
                                    当数据与现有分区不匹配时，会将其插入默认分区。
                                    没有默认分区的分区设计将拒绝与现有分区不匹配的传入行。
                                </pd>
                                <pd>
                                    <b>
                                        <codeph>PARTITION
                                            <varname>name</varname>
                                        </codeph>
                                    </b>
                                    — 声明要用于分区的名称。
                                    使用以下命名约定创建分区：<codeph><varname>parentname</varname>_<varname>level#</varname>_prt_<varname>givenname</varname></codeph>。
                                </pd>
                                <pd>
                                    <b>
                                        <codeph>VALUES</codeph>
                                    </b>
                                    — 对于列表分区，定义分区将包含的值。
                                </pd>
                                <pd>
                                    <b>
                                        <codeph>START</codeph>
                                    </b>
                                    — 对于范围分区，定义分区的起始范围值。
                                    默认情况下，起始值为<codeph>INCLUSIVE</codeph>。
                                    例如，如果您声明开始日期为'<codeph>2016-01-01</codeph>'，
                                    则分区将包含所有大于或等于'<codeph>2016-01-01</codeph>'的日期。
                                    通常，<codeph>START</codeph>表达式的数据类型与分区键列的类型相同。
                                    如果不是这种情况，则必须显式转换为预期的数据类型。
                                </pd>
                                <pd>
                                    <b>
                                        <codeph>END</codeph>
                                    </b>
                                    — 对于范围分区，定义分区的结束范围值。
                                    默认情况下，结束值为<codeph>EXCLUSIVE</codeph>。
                                    例如，如果您声明结束日期为'<codeph>2016-02-01</codeph>'，
                                    则分区将包含所有小于但不等于'<codeph>2016-02-01</codeph>'的日期。
                                    通常，<codeph>END</codeph>表达式的数据类型与分区键列的类型相同。
                                    如果不是这种情况，则必须显式转换为预期的数据类型。
                                </pd>
                                <pd>
                                    <b>
                                        <codeph>EVERY</codeph>
                                    </b>
                                    — 对于范围分区，定义如何将值从<codeph>START</codeph>递增到<codeph>END</codeph>以创建单个分区。
                                    通常，<codeph>EVERY</codeph>表达式的数据类型与分区键列的类型相同。
                                    如果不是这种情况，则必须显式转换为预期的数据类型。
                                </pd>
                                <pd>
                                    <b>
                                        <codeph>WITH</codeph>
                                    </b>
                                    — 设置分区的表存储选项。
                                    例如，您可能希望将较旧的分区作为追加优化表，而将较新的分区作为常规堆表。
                                </pd>
                                <pd>
                                    <b>
                                        <codeph>TABLESPACE</codeph>
                                    </b>
                                    — 要在其中创建分区的表空间的名称。
                                </pd>
                            </plentry>
                        </parml>
                    </pd>
                </plentry>
                <plentry>
                    <pt>SUBPARTITION BY</pt>
                    <pd>声明用于对表的第一级分区进行子分区的一个或多个列。
                        子分区的规范格式类似于上述分区的规范格式。
                    </pd>
                </plentry>
                <plentry>
                    <pt>SUBPARTITION TEMPLATE</pt>
                    <pd>您可以选择声明一个用于创建子分区的子分区模板（低级别子表），而不是为每个分区分别声明每个子分区定义。
                        然后，此子分区规范将应用于所有父分区。
                    </pd>
                </plentry>
            </parml>
        </section>
        <section id="section5">
            <title>注解</title>
            <ul id="ul_stf_sl1_tt">
                <li>在Greenplum数据库（基于Postgres的系统）中，
                    数据类型<codeph>VARCHAR</codeph>或<codeph>TEXT</codeph>处理填充作为有效字符添加到文本的数据（最后一个非空格字符之后添加空格字符）；
                    数据类型<codeph>CHAR</codeph>则没有。
                    <p>在Greenplum数据库中，<codeph>CHAR(<varname>n</varname>)</codeph>类型的值用尾随空格填充到指定的宽度<varname>n</varname>。
                        值将存储并显示为空格。
                        但是，填充空格在语义上无关紧要。
                        分配值时，将忽略尾随空格。
                        比较数据类型<codeph>CHAR</codeph>的两个值时，尾随空格在语义上也无关紧要，
                        而将字符值转换为其他字符串类型之一时，尾随空格也将被删除。
                    </p>
                </li>
                <li>不建议在新应用程序中使用OID：在可能的情况下，最好使用<codeph>SERIAL</codeph>或其他序列生成器作为表的主键。
                    但是，如果您的应用程序确实使用OID来标识表的特定行，
                    则建议在该表的OID列上创建唯一约束，以确保即使在计数器回绕后，表中的OID的确可以唯一地标识行。
                    避免假设OID在表之间是唯一的；如果需要数据库范围的唯一标识符，则可以使用表OID和行OID的组合。
                </li>
                <li>Greenplum数据库对于主键和作为Greenplum表中的分布键的列的唯一约束具有一些特殊条件。
                    为了在Greenplum数据库中实施唯一约束，表必须是哈希分布的（不是<codeph>DISTRIBUTED RANDOMLY</codeph>），
                    并且约束列必须与表的分布键列相同（或作为其的超集）。
                    另外，分布键必须是约束列的左子集，并且列的顺序正确。
                    例如，如果主键是（a，b，c），则分布键只能是以下之一：（a），（a，b）或（a，b，c）。
                    <p>复制表（<codeph>DISTRIBUTED REPLICATED</codeph>）可以同时具有<codeph>PRIMARY KEY</codeph>和<codeph>UNIQUE</codeph>列约束。
                    </p>
                    <p>主键约束只是唯一约束和非空约束的组合。
                    </p>
                    <p>Greenplum数据库自动为每个<codeph>UNIQUE</codeph>或<codeph>PRIMARY KEY</codeph>约束创建一个<codeph>UNIQUE</codeph>索引，以强制执行唯一性。
                        因此，没有必要为主键列显式创建索引。
                        在追加优化表上不允许使用<codeph>UNIQUE</codeph>和<codeph>PRIMARY KEY</codeph>约束，因为在追加优化表上不允许通过约束创建的<codeph>UNIQUE</codeph>索引。
                    </p>
                    <p>Greenplum数据库中不支持外键约束。
                    </p>
                    <p>对于继承的表，当前实现中不会继承唯一约束，主键约束，索引和表特权。
                    </p>
                </li>
                <li>对于追加优化的表，可重复读或可序列化事务中不允许<codeph>UPDATE</codeph>和<codeph>DELETE</codeph>，这将导致事务中止。
                    <codeph>CLUSTER</codeph>，<codeph>DECLARE...FOR UPDATE</codeph>和触发器不支持追加优化的表。
                </li>
                <li>要将数据插入分区表中，请指定根分区表，即使用<codeph>CREATE TABLE</codeph>命令创建的表。
                    您还可以在<codeph>INSERT</codeph>命令中指定分区表的叶子表。
                    如果数据对于指定的叶子表无效，则返回错误。
                    不支持在<codeph>INSERT</codeph>命令中指定不是叶子表的子表。
                    不支持在分区表的任何子表上执行其他DML命令，例如<codeph>UPDATE</codeph>和<codeph>DELETE</codeph>。
                    这些命令必须在根分区表（使用<codeph>CREATE TABLE</codeph>命令创建的表）上执行。
                </li>
                <li>可以使用服务器配置参数<codeph>gp_default_storage_option</codeph>指定这些表存储选项的默认值。
                    <ul id="ul_hr1_3m1_tt">
                        <li>
                            <cmdname>appendoptimized</cmdname>
                        </li>
                        <li>
                            <cmdname>blocksize</cmdname>
                        </li>
                        <li>
                            <cmdname>checksum</cmdname>
                        </li>
                        <li>
                            <cmdname>compresstype</cmdname>
                        </li>
                        <li>
                            <cmdname>compresslevel</cmdname>
                        </li>
                        <li>
                            <cmdname>orientation</cmdname>
                        </li>
                    </ul>
                    <p>可以为系统，数据库或用户设置默认值。
                        有关设置存储选项的信息，请参阅服务器配置参数<codeph><xref href="../../ref_guide/config_params/guc-list.xml#gp_default_storage_options">gp_default_storage_options</xref></codeph>。
                    </p>
                </li>
            </ul>
            <note type="important">当前的Greenplum数据库Postgres优化器允许使用具有多列（复合）分区键的列表分区。
                GPORCA不支持复合键，因此不建议使用复合分区键。
            </note>
        </section>
        <section id="section6">
            <title>示例</title>
            <p>在名为<codeph>baby</codeph>的模式中创建一个名为<codeph>rank</codeph>的表，
                并使用<codeph>rank</codeph>，<codeph>gender</codeph>和<codeph>year</codeph>列分发数据：
            </p>
            <codeblock>CREATE TABLE baby.rank (id int, rank int, year smallint,
gender char(1), count int ) DISTRIBUTED BY (rank, gender,
year);</codeblock>
      <p>创建表files和表分配器（默认情况下，主键将用作Greenplum分布键）：</p>
      <codeblock>CREATE TABLE films (
code        char(5) CONSTRAINT firstkey PRIMARY KEY,
title       varchar(40) NOT NULL,
did         integer NOT NULL,
date_prod   date,
kind        varchar(10),
len         interval hour to minute
);

CREATE TABLE distributors (
did    integer PRIMARY KEY DEFAULT nextval('serial'),
name   varchar(40) NOT NULL CHECK (name &lt;&gt; '')
);</codeblock>
      <p>创建一个gzip压缩的，追加优化的表：</p>
      <codeblock>CREATE TABLE sales (txn_id int, qty int, date date) 
WITH (appendoptimized=true, compresslevel=5) 
DISTRIBUTED BY (txn_id);</codeblock>
      <p>使用子分区模板和每个级别的默认分区创建一个三级分区表：</p>
      <codeblock>CREATE TABLE sales (id int, year int, month int, day int, 
region text)
DISTRIBUTED BY (id)
PARTITION BY RANGE (year)

  SUBPARTITION BY RANGE (month)
    SUBPARTITION TEMPLATE (
       START (1) END (13) EVERY (1), 
       DEFAULT SUBPARTITION other_months )

  SUBPARTITION BY LIST (region)
    SUBPARTITION TEMPLATE (
       SUBPARTITION usa VALUES ('usa'),
       SUBPARTITION europe VALUES ('europe'),
       SUBPARTITION asia VALUES ('asia'),
       DEFAULT SUBPARTITION other_regions)

( START (2008) END (2016) EVERY (1),
  DEFAULT PARTITION outlying_years);</codeblock>
        </section>
        <section id="section7">
            <title>兼容性</title>
            <p><codeph>CREATE TABLE</codeph>命令符合SQL标准，但以下情况除外：
            </p>
            <ul>
                <li id="cd150267">
                    <b>Temporary Tables</b>
                    — 在SQL标准中，临时表仅定义一次，并在每个需要它们的会话中自动存在（从空内容开始）。
                    相反，Greenplum数据库要求每个会话为要使用的每个临时表发出自己的<codeph>CREATE TEMPORARY TABLE</codeph>命令。
                    这允许不同的会话出于不同的目的而使用相同的临时表名称，而标准的方法将给定临时表名称的所有实例约束为具有相同的表结构。
                    <p>全局和本地临时表之间的标准区别不在Greenplum数据库中。
                        Greenplum数据库将在临时表声明中接受<codeph>GLOBAL</codeph>和<codeph>LOCAL</codeph>关键字，但它们无效且已弃用。
                    </p>
                    <p>如果省略<codeph>ON COMMIT</codeph>子句，则SQL标准将默认行为指定为<codeph>ON COMMIT DELETE ROWS</codeph>。
                        但是，Greenplum数据库中的默认行为是<codeph>ON COMMIT PRESERVE ROWS</codeph>。
                        SQL标准中不存在<codeph>ON COMMIT DROP</codeph>选项。
                    </p>
                </li>
                <li id="cd150376">
                    <b>Column Check Constraints</b>
                    — SQL标准说，<codeph>CHECK</codeph>列约束只能引用它们所适用的列。
                    只有<codeph>CHECK</codeph>表约束可以引用多个列。
                    Greenplum数据库不强制执行此限制；它对待列和表检查约束都一样。
                </li>
                <li id="cd150386">
                    <b>NULL Constraint</b>
                    — <codeph>NULL</codeph>约束是对SQL标准的Greenplum数据库扩展，
                    为了与某些其他数据库系统兼容（以及对称的<codeph>NOT NULL</codeph>约束）。
                    由于它是任何列的默认值，因此不需要它的存在。
                </li>
                <li id="cd150401">
                    <b>Inheritance</b>
                    — 通过<codeph>INHERITS</codeph>子句的多重继承是Greenplum数据库语言的扩展。
                    SQL：1999及更高版本使用不同的语法和语义定义了单个继承。
                    Greenplum数据库尚不支持SQL：1999样式的继承。
                </li>
                <li id="cd153512">
                    <b>Partitioning</b>
                    — 通过<codeph>PARTITION BY</codeph>子句进行的表分区是Greenplum数据库语言的扩展。
                </li>
                <li id="cd150414">
                    <b>Zero-column tables</b>
                    — Greenplum数据库允许创建不包含任何列的表（例如<codeph>CREATE TABLE foo();</codeph>）。
                    这是SQL标准的扩展，不允许使用零列表。
                    零列表本身并没有什么用，但是不允许使用零列表在<codeph>ALTER TABLE DROP COLUMN</codeph>时会产生奇怪的特殊情况，
                    因此Greenplum决定忽略此规范限制。
                </li>
                <li>
                    <b>LIKE</b>
                    — 尽管SQL标准中存在<codeph>LIKE</codeph>子句，
                    但Greenplum数据库接受的许多选项都不在该标准中，并且Greenplum数据库并未实现该标准的某些选项。
                </li>
                <li id="cd150435">
                    <b>WITH clause</b>
                    — <codeph>WITH</codeph>子句是Greenplum数据库扩展。
                    存储参数和OID都不在标准中。
                </li>
                <li id="cd150445">
                    <b>Tablespaces</b>
                    — 表空间的Greenplum数据库概念不是SQL标准的一部分。
                    子句<codeph>TABLESPACE</codeph>和<codeph>USING INDEX TABLESPACE</codeph>是扩展。
                </li>
                <li id="cd150459">
                    <b>Data Distribution</b>
                    — 并行或分布式数据库的Greenplum数据库概念不是SQL标准的一部分。
                    <codeph>DISTRIBUTED</codeph>子句是扩展。
                </li>
            </ul>
        </section>
        <section id="section8">
            <title>另见</title>
            <p>
                <codeph>
                    <xref href="ALTER_TABLE.xml#topic1" type="topic" format="dita">ALTER
                        TABLE
                    </xref>
                </codeph>
                ,
                <codeph>
                    <xref href="./DROP_TABLE.xml#topic1" type="topic"
                          format="dita">DROP TABLE
                    </xref>
                </codeph>
                ,
                <codeph>
                    <xref
                            href="CREATE_EXTERNAL_TABLE.xml#topic1" type="topic" format="dita">CREATE EXTERNAL
                        TABLE
                    </xref>
                </codeph>
                ,
                <codeph>
                    <xref href="./CREATE_TABLE_AS.xml#topic1" type="topic"
                          format="dita">CREATE TABLE AS
                    </xref>
                </codeph>
            </p>
        </section>
    </body>
</topic>
