<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE dita PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<dita>
  <topic id="topic_abq_gfk_qfb">
    <title>日期/时间类型</title>
    <body><section id="datatype-datetime">
   

   <p>Greenplum 完整支持全部 SQL 日期和时间类型, 参见 <xref
      href="#topic_abq_gfk_qfb/datatype-datetime-table" format="dita"/>。对于这些数据类型可用的操作说明, 参见 PostgreSQL 文档 <xref
      href="https://www.postgresql.org/docs/9.4/functions-datetime.html" format="html"
      scope="external">日期/时间函数和运算符</xref>。
     日期根据罗马日历计算，在日历引入之前的年也这样计算 (参见 PostgreSQL 文档 <xref
      href="https://www.postgresql.org/docs/9.4/datetime-units-history.html" format="html"
      scope="external">日期单位的历史</xref>了解更多信息)。</p>

    <table id="datatype-datetime-table">
     <title>日期/时间类型</title>
     <tgroup cols="6">
      <thead>
       <row>
        <entry>名称</entry>
        <entry>存储大小</entry>
        <entry>描述</entry>
        <entry>最小值</entry>
        <entry>最大值</entry>
        <entry>精度</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>timestamp [ (<varname>p</varname>) ] [ without time zone ]</entry>
        <entry>8 字节</entry>
        <entry>包括时间和日期 (无时区)</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 微秒 / 14 位数字</entry>
       </row>
       <row>
        <entry>timestamp [ (<varname>p</varname>) ] with time zone</entry>
        <entry>8 字节</entry>
        <entry>包括时间和日期 (有时区)</entry>
        <entry>4713 BC</entry>
        <entry>294276 AD</entry>
        <entry>1 微秒 / 14 位数字</entry>
       </row>
       <row>
        <entry>date</entry>
        <entry>4 字节</entry>
        <entry>日期 (无一天内的时间)</entry>
        <entry>4713 BC</entry>
        <entry>5874897 AD</entry>
        <entry>1 天</entry>
       </row>
       <row>
        <entry>time [ (<varname>p</varname>) ] [ without time zone ]</entry>
        <entry>8 字节</entry>
        <entry>一天内的时间 (无日期和时区)</entry>
        <entry>00:00:00</entry>
        <entry>24:00:00</entry>
        <entry>1 微秒 / 14 位数字</entry>
       </row>
       <row>
        <entry>time [ (<varname>p</varname>) ] with time zone</entry>
        <entry>12 字节</entry>
        <entry>一天内的时间, 无日期, 有时区</entry>
        <entry>00:00:00+1459</entry>
        <entry>24:00:00-1459</entry>
        <entry>1 微秒 / 14 位数字</entry>
       </row>
       <row>
        <entry>interval [ <varname>fields</varname> ] [ (<varname>p</varname>) ]</entry>
        <entry>16 字节</entry>
        <entry>时间间隔</entry>
        <entry>-178000000 年</entry>
        <entry>178000000 年</entry>
        <entry>1 微秒 / 14 位数字</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>SQL 标准要求 <codeph>timestamp</codeph> 与 <codeph>timestamp without time zone</codeph> 写法一致, Greenplum 实现了这一点。
      <codeph>timestamptz</codeph> 是 <codeph>timestamp with time
      zone</codeph> 的缩写; 这是 PostgreSQL 的一点扩展。 </note>

   <p><codeph>time</codeph>, <codeph>timestamp</codeph>, 和 <codeph>interval</codeph> 接受一个可选的精度值 <varname>p</varname>，来指定秒的小数部分数字。默认情况下, 没有明确精度指定。对于 <codeph>timestamp</codeph> 和
      <codeph>interval</codeph> 类型, 允许的 <varname>p</varname> 值范围为 0 到 6。</p>

   <note>当 <codeph>timestamp</codeph> 值按八字节整数存储(当前默认), 精度可全范围(0 到 6 位)任意设置。当
      <codeph>timestamp</codeph> 值按双精度浮点数存储(一个过时的编译选项), 精度有效值可能小于 6 位。<codeph>timestamp</codeph> 值存储的是从 2000-01-01 午夜开始的秒的数值。
      当 <codeph>timestamp</codeph> 值按浮点数实现时，2000-01-01 附近的一些年可以达到微秒精度，但是距离这个日期稍远的一些时间精度就会有所降低。注意：浮点存储的<codeph>timestamp</codeph> 值允许更大的日期范围，比上表中给出的要大，即可以表示从 4713 BC 到
     5874897 AD 的日期。<p>同样的编译选项也决定 <codeph>time</codeph> 和
       <codeph>interval</codeph> 类型值存储为浮点数还是八字节整数。
      当存储位浮点数的时候, 当时间间隔增大时，<codeph>interval</codeph> 的精度有所降低。</p></note>

   <p>对于 <codeph>time</codeph> 类型, 使用八字节整数存储时，允许的
    <varname>p</varname> 值范围从 0 到 6；使用浮点数存储时，允许的<varname>p</varname> 值范围从 0 到 10。</p>

   <p>另外，<codeph>interval</codeph> 数据类型还有一个附加选项，可以通过书写以下时间单位后缀(<varname>fields</varname>)来来限制存储内容:
<codeblock>
YEAR
MONTH
DAY
HOUR
MINUTE
SECOND
YEAR TO MONTH
DAY TO HOUR
DAY TO MINUTE
DAY TO SECOND
HOUR TO MINUTE
HOUR TO SECOND
MINUTE TO SECOND
</codeblock>
    注意：如果同时指定 <varname>fields</varname> 与
    <varname>p</varname> 参数, 
    <varname>fields</varname> 必须包含 <codeph>SECOND</codeph>,
    因为精度参数 <varname>p</varname> 只对秒起作用。</p>

   <p><codeph>time with time zone</codeph> 类型由 SQL 标准定义，
    但是定义给出的属性导致人们怀疑它的有用性。
    大部分情况下，复合使用
    <codeph>date</codeph>, <codeph>time</codeph>, <codeph>timestamp without time
    zone</codeph>, 以及 <codeph>timestamp with time zone</codeph> 已经提供了任何应用程序所需的完整日期/时间功能。</p>

   <p><codeph>abstime</codeph> 
    和 <codeph>reltime</codeph> 是内部使用的低精度数据类型。
    不建议你在应用程序中使用; 这些内部数据类型可能在未来的某一个版本中消失。</p>

    </section>
   <section id="datatype-datetime-input">
    <title>日期/时间输入</title>

    <p>几乎任何合理的日期/时间输入格式都可以被接受。包括 ISO 8601,
     SQL-兼任格式, 传统 POSTGRES 格式, 等等。对于一些格式, 数据输入中的年、月、日的顺序非常含糊，所以支持指定这些字段的期望顺序。参见 <xref href="config_params/guc-list.xml#DateStyle"/> 通过参数
      <codeph>MDY</codeph> 指定 月-日-年 格式, <codeph>DMY</codeph> 指定 日-月-年 格式，或者 <codeph>YMD</codeph> 指定 年-月-日 格式。</p>

    <p>Greenplum 在处理日期/时间输入上比 SQL 标准要求的更加弹性。参见 PostgreSQL 文档
      <xref href="https://www.postgresql.org/docs/9.4/datetime-appendix.html" format="html"
      scope="external">附录 B. 时间/日期支持</xref>，了解时间/日期输入的确切解析规则，以及如何识别文本字段，包括月份, 星期和时区。</p>

    <p>记住，任何日期或时间字面值需要用单引号引起来, 就像字符串一样. SQL 需要这样的语法
     <codeblock>
<varname>type</varname> [ (<varname>p</varname>) ] '<varname>value</varname>'
</codeblock>
     这里， <varname>p</varname> 是一个可选精度参数，指定秒的小数位数。它对以下类型起作用， <codeph>time</codeph>,
      <codeph>timestamp</codeph>, 以及 <codeph>interval</codeph> 类型。
      允许设定的值范围已经在上面文档中说明； 如果没有指定精度，默认为字面值的精度。</p>

   </section>
    <section>
    <title>日期</title>

    <p><xref href="#topic_abq_gfk_qfb/table_owm_dfr_qfb" format="dita"/> 一些可能的 <codeph>date</codeph> 类型输入格式.</p>

     <table id="table_owm_dfr_qfb">
     <title>日期输入</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>举例</entry>
        <entry>说明</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>1999-01-08</entry>
        <entry>ISO 8601; 1 月 8 日 (推荐格式)</entry>
       </row>
       <row>
        <entry>January 8, 1999</entry>
        <entry>对任何 <varname>日期风格</varname> 都很明确的输入模式</entry>
       </row>
       <row>
        <entry>1/8/1999</entry>
        <entry><codeph>MDY</codeph> 模式：1 月 8 日 ; <codeph>DMY</codeph> 模式：8 月 1 日</entry>
       </row>
       <row>
        <entry>1/18/1999</entry>
        <entry><codeph>MDY</codeph> 模式：1 月 18 日; 其他模式：无效</entry>
       </row>
       <row>
        <entry>01/02/03</entry>
        <entry><codeph>MDY</codeph> 模式：2003 年 1 月 2 日; 
          <codeph>DMY</codeph> 模式：2003 年 2 月 1 日; 
          <codeph>YMD</codeph> 模式：2001 年 2 月 3 日 </entry>
       </row>
       <row>
        <entry>1999-Jan-08</entry>
        <entry>任何模式：1999 年 1 月 8 日</entry>
       </row>
       <row>
        <entry>Jan-08-1999</entry>
        <entry>任何模式：1999 年 1 月 8 日</entry>
       </row>
       <row>
        <entry>08-Jan-1999</entry>
        <entry>任何模式：1999 年 1 月 8 日</entry>
       </row>
       <row>
        <entry>99-Jan-08</entry>
        <entry><codeph>YMD</codeph> 模式：1999 年 1 月 8 日, 其他：错误</entry>
       </row>
       <row>
        <entry>08-Jan-99</entry>
        <entry><codeph>YMD</codeph> 模式：错误；其他模式：1999 年 1 月 8 日</entry>
       </row>
       <row>
        <entry>Jan-08-99</entry>
        <entry><codeph>YMD</codeph> 模式：错误；其他模式：1999 年 1 月 8 日</entry>
       </row>
       <row>
        <entry>19990108</entry>
        <entry>ISO 8601; 任何模式：1999 年 1 月 8 日</entry>
       </row>
       <row>
        <entry>990108</entry>
        <entry>ISO 8601; 任何模式：1999 年 1 月 8 日</entry>
       </row>
       <row>
        <entry>1999.008</entry>
        <entry>年和一年中的天</entry>
       </row>
       <row>
        <entry>J2451187</entry>
        <entry>儒略日期（天文学常用）</entry>
       </row>
       <row>
        <entry>January 8, 99 BC</entry>
        <entry>公元前 99 年 1 月 8 日</entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    </section>

    <section>
     <title>时间</title>

     <p>时间类型包括 <codeph>time [
      (<varname>p</varname>) ] without time zone</codeph> 和
      <codeph>time [ (<varname>p</varname>) ] with time
      zone</codeph>。  <codeph>time</codeph> 与
      <codeph>time without time zone</codeph> 等价.</p>

     <p>这些类型的有效的输入格式由时间加上一个可选的时区.
     (参见 <xref href="#topic_abq_gfk_qfb/datatype-datetime-time-table" format="dita"/> 和 <xref
      href="#topic_abq_gfk_qfb/datatype-timezone-table" format="dita"/>.) 如果在输入中给 <codeph>time without time zone</codeph> 类型指定了时区, 则时区会被忽略。你如果指定了一个日期，也会被忽略，除非你用了包含夏令时的时区，例如 <codeph>America/New_York</codeph>. 
      这种情况下，指定日期是必要的，因为需要决定当前是否是标准时间，还是夏令时时间. 
      使用 <codeph>time with time
      zone</codeph> 类型时，合适的时区偏移会被记录.</p>

      <table id="datatype-datetime-time-table">
       <title>时间输入</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>举例</entry>
          <entry>说明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><codeph>04:05:06.789</codeph></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><codeph>04:05:06</codeph></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><codeph>04:05</codeph></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><codeph>040506</codeph></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><codeph>04:05 AM</codeph></entry>
          <entry>与 04:05 相同; AM 不影响值</entry>
         </row>
         <row>
          <entry><codeph>04:05 PM</codeph></entry>
          <entry>与 16:05 相同; 小时值必须 &lt;= 12</entry>
         </row>
         <row>
          <entry><codeph>04:05:06.789-8</codeph></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><codeph>04:05:06-08:00</codeph></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><codeph>04:05-08:00</codeph></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><codeph>040506-08</codeph></entry>
          <entry>ISO 8601</entry>
         </row>
         <row>
          <entry><codeph>04:05:06 PST</codeph></entry>
          <entry>时区用缩写指定</entry>
         </row>
         <row>
          <entry><codeph>2003-04-12 04:05:06 America/New_York</codeph></entry>
          <entry>时区用全称指定</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

      <table id="datatype-timezone-table">
       <title>时区输入</title>
       <tgroup cols="2">
        <thead>
         <row>
          <entry>举例</entry>
          <entry>说明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><codeph>PST</codeph></entry>
          <entry>缩写 (太平洋标准时间)</entry>
         </row>
         <row>
          <entry><codeph>America/New_York</codeph></entry>
          <entry>时区全称</entry>
         </row>
         <row>
          <entry><codeph>PST8PDT</codeph></entry>
          <entry>POSIX-样式时区格式</entry>
         </row>
         <row>
          <entry><codeph>-8:00</codeph></entry>
          <entry>ISO-8601 偏移(PST)</entry>
         </row>
         <row>
          <entry><codeph>-800</codeph></entry>
          <entry>ISO-8601 偏移(PST)</entry>
         </row>
         <row>
          <entry><codeph>-8</codeph></entry>
          <entry>ISO-8601 偏移(PST)</entry>
         </row>
         <row>
          <entry><codeph>zulu</codeph></entry>
          <entry>军方缩写(UTC)</entry>
         </row>
         <row>
          <entry><codeph>z</codeph></entry>
          <entry><codeph>zulu</codeph>的短格式</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <p>参考 <xref href="#topic_abq_gfk_qfb/datatype-timezones" format="dita"/> 了解更多时区格式输入信息.</p>
    </section>

    <section>
    <title>时间戳</title>

     <p>时间戳的有效输入格式由以下几个部分组成：日期，时间，时区(可选),
      接着可选的 <codeph>AD</codeph> 或 <codeph>BC</codeph>.
      (另外, <codeph>AD</codeph>/<codeph>BC</codeph> 也可以出现在时区之前, 但不是推荐的顺序.)
      因而:

<codeph>
1999-01-08 04:05:06
</codeph>
      和:
<codeph>
1999-01-08 04:05:06 -8:00
</codeph>

      都是有效的时间戳值, 它们满足 ISO 8601 标准要求.
      另外, 常用格式:
<codeph>
January 8 04:05:06 1999 PST
</codeph>
      也被支持.</p>

     <p>SQL 标准中 <codeph>timestamp without time zone</codeph> 与
      <codeph>timestamp with time zone</codeph> 字面值的差异主要体现在时间后面由一个 <codeph>+</codeph> 或
      <codeph>-</codeph> 号标识的时区. 因此, 根据标准, <codeph>TIMESTAMP '2004-10-19 10:23:54'</codeph> 是一个 <codeph>timestamp without time
      zone</codeph> 类型字面值, 而 <codeph>TIMESTAMP '2004-10-19 10:23:54+02'</codeph> 是一个
      <codeph>timestamp with time zone</codeph> 类型的字面值. Greenplum 在确定类型之前从不检查字面值内容, 所以上面两个字面值都会被认为是
      <codeph>timestamp without time zone</codeph> 类型. 为确保当作
      <codeph>timestamp with time zone</codeph> 类型对待, 请像这样给出明确类型:
      <codeph>TIMESTAMP WITH TIME ZONE '2004-10-19 10:23:54+02'</codeph>
      对于一个已经确定为 <codeph>timestamp without time zone</codeph>类型的字面值, Greenplum 会抛弃时区相关信息. 也就是说, 结果时间戳仅仅根据日期/时间确定，不会根据时区进行调整.</p>

     <p>对于 <codeph>timestamp with time zone</codeph> 类型, 内部值总是按照 UTC
     (统一协调时间, 通常叫做格林威治时间, GMT) 存储.
     带有明确时区的输入值会使用合适的时区偏移转为 UTC 时间。
     如果输入字符串中没有指定时区，会假定为当前系统的 <codeph>TimeZone</codeph> 参数, 并使用这个参数的偏移转换为 UTC 时间。</p>

     <p>当输出一个 <codeph>timestamp with time zone</codeph> 类型值,
     总是根据当前 <varname>timezone</varname> 时区值进行转换, 并显示为本地时间. 要想以另一个时区查看时间，要么改变 <varname>timezone</varname> 设置，要么使用 <codeph>AT TIME ZONE</codeph> 构造 (参见 PostgreSQL 文档的<xref
      href="https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-ZONECONVERT"
      format="html" scope="external">AT TIME ZONE</xref>).</p>

     <p>在 <codeph>timestamp without time zone</codeph> 与
      <codeph>timestamp with time zone</codeph> 间转换通常假定
      <codeph>timestamp without time zone</codeph> 中的值应该是以 <varname>timezone</varname> 为时区的本地时间. 当然，也可以用 <codeph>AT TIME ZONE</codeph> 指定一个不同的时区.</p>
    </section>

    <section>
     <title>特殊值</title>

     <p>为了方便, Greenplum 支持几种特殊的日期/时间输入值格式, 参见 <xref
      href="#topic_abq_gfk_qfb/datatype-datetime-special-table" format="dita"/>. 
      <codeph>infinity</codeph> 和 <codeph>-infinity</codeph> 值是用于系统内部的特殊表示，会被直接显示;
      但其他都只是些快捷记号，会在读取的时候被转换为常规的日期/时间值.(特别地, <codeph>now</codeph>
     和相关字符串会被转换为读取时的当前特定时间值.) 所有这些常量值在 SQL 命令中都需要用单引号引起来.</p>

      <table id="datatype-datetime-special-table">
       <title>特殊日期/时间输入</title>
       <tgroup cols="3">
        <thead>
         <row>
          <entry>输入字符串</entry>
          <entry>有效类型</entry>
          <entry>说明</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><codeph>epoch</codeph></entry>
          <entry><codeph>date</codeph>, <codeph>timestamp</codeph></entry>
          <entry>1970-01-01 00:00:00+00 (Unix 系统时间零点)</entry>
         </row>
         <row>
          <entry><codeph>infinity</codeph></entry>
          <entry><codeph>date</codeph>, <codeph>timestamp</codeph></entry>
          <entry>比任何时间戳都晚的时间</entry>
         </row>
         <row>
          <entry><codeph>-infinity</codeph></entry>
          <entry><codeph>date</codeph>, <codeph>timestamp</codeph></entry>
          <entry>比任何时间戳都早的时间</entry>
         </row>
         <row>
          <entry><codeph>now</codeph></entry>
          <entry><codeph>date</codeph>, <codeph>time</codeph>, <codeph>timestamp</codeph></entry>
          <entry>当前事务的开始时间</entry>
         </row>
         <row>
          <entry><codeph>today</codeph></entry>
          <entry><codeph>date</codeph>, <codeph>timestamp</codeph></entry>
          <entry>今天午夜</entry>
         </row>
         <row>
          <entry><codeph>tomorrow</codeph></entry>
          <entry><codeph>date</codeph>, <codeph>timestamp</codeph></entry>
          <entry>明天午夜</entry>
         </row>
         <row>
          <entry><codeph>yesterday</codeph></entry>
          <entry><codeph>date</codeph>, <codeph>timestamp</codeph></entry>
          <entry>昨天午夜</entry>
         </row>
         <row>
          <entry><codeph>allballs</codeph></entry>
          <entry><codeph>time</codeph></entry>
          <entry>00:00:00.00 UTC</entry>
         </row>
        </tbody>
       </tgroup>
      </table>

     <p>下面这些 SQL-兼容函数也可以用来获取相应类型的当前时间: <codeph>CURRENT_DATE</codeph>, <codeph>CURRENT_TIME</codeph>,
      <codeph>CURRENT_TIMESTAMP</codeph>, <codeph>LOCALTIME</codeph>,
      <codeph>LOCALTIMESTAMP</codeph>. 后面四个可接受一个可选的亚秒级精度参数. (参见 PostgreSQL 文档的<xref
      href="https://www.postgresql.org/docs/9.4/functions-datetime.html#FUNCTIONS-DATETIME-CURRENT"
      format="html" scope="external">当前日期/时间</xref>.) 注意
     有一些 SQL 函数在输入字符串中 <i>不</i> 被接受.</p>

    </section>
   

   <section id="datatype-datetime-output">
    <title>日期/时间输出</title>

    
    <p>日期/时间类型的输出格式可以被设置为以下四种样式: ISO 8601, SQL
     (Ingres), 传统 POSTGRES (Unix <codeph>date</codeph> 格式), 或者 German. 默认是 ISO 格式. (SQL 标准需要使用 ISO 8601 格式. 
      <codeph>SQL</codeph> 输出格式这个名字是由于偶然的历史原因.) <xref
      href="#topic_abq_gfk_qfb/datatype-datetime-output-table" format="dita"/> 给出了各种输出格式的例子. <codeph>date</codeph> 和 <codeph>time</codeph> 类型的输出格式通常为对应例子中的日期或时间部分.
      然而, POSTGRES 格式的纯日期输出用的是 ISO 格式.</p>

     <table id="datatype-datetime-output-table">
      <title>日期/时间输出格式</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>样式规范</entry>
         <entry>说明</entry>
         <entry>举例</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><codeph>ISO</codeph></entry>
         <entry>ISO 8601, SQL 标准</entry>
         <entry><codeph>1997-12-17 07:37:16-08</codeph></entry>
        </row>
        <row>
         <entry><codeph>SQL</codeph></entry>
         <entry>传统样式</entry>
         <entry><codeph>12/17/1997 07:37:16.00 PST</codeph></entry>
        </row>
        <row>
         <entry><codeph>Postgres</codeph></entry>
         <entry>原始样式</entry>
         <entry><codeph>Wed Dec 17 07:37:16 1997 PST</codeph></entry>
        </row>
        <row>
         <entry><codeph>German</codeph></entry>
         <entry>区域样式</entry>
         <entry><codeph>17.12.1997 07:37:16.00 PST</codeph></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <note> ISO 8601 规定使用大写字母 <codeph>T</codeph> 隔开日期和时间. Greenplum 支持这个输入格式, 但是输出时使用空格而不是
      <codeph>T</codeph>, 上面您已经看到了. 这是为了可读性，同时与 RFC 3339 以及一些其他数据库系统保持一致. </note>

    <p>在 SQL 和 POSTGRES 样式中, 如果指定 DMY 模式，日会出现在月之前; 其他情况下月在日之前. (参见 <xref
      href="#topic_abq_gfk_qfb/table_owm_dfr_qfb" format="dita"/> 关于这些设置如何影响输入值解释.) <xref
      href="#topic_abq_gfk_qfb/datatype-datetime-output2-table" format="dita"/> 中的例子.</p>

     <table id="datatype-datetime-output2-table">
      <title>日期顺序约定</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry><varname>datestyle</varname> 设置</entry>
         <entry>输入顺序</entry>
         <entry>输出举例</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><codeph>SQL, DMY</codeph></entry>
         <entry><varname>day</varname>/<varname>month</varname>/<varname>year</varname></entry>
         <entry><codeph>17/12/1997 15:37:16.00 CET</codeph></entry>
        </row>
        <row>
         <entry><codeph>SQL, MDY</codeph></entry>
         <entry><varname>month</varname>/<varname>day</varname>/<varname>year</varname></entry>
         <entry><codeph>12/17/1997 07:37:16.00 PST</codeph></entry>
        </row>
        <row>
         <entry><codeph>Postgres, DMY</codeph></entry>
         <entry><varname>day</varname>/<varname>month</varname>/<varname>year</varname></entry>
         <entry><codeph>Wed 17 Dec 07:37:16 1997 PST</codeph></entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <p>用户可以使用以下方式选择日期/时间样式: <codeph>SET datestyle</codeph> 命令,
    <codeph>postgresql.conf</codeph>
     配置文件中的 <codeph>DateStyle</codeph> 参数, 或者服务器或客户端的 <codeph>PGDATESTYLE</codeph> 环境变量.</p>

    <p>格式化函数 <codeph>to_char</codeph> (参见 <xref
      href="https://www.postgresql.org/docs/9.4/functions-formatting.html" format="html"
      scope="external">数据类型格式化函数</xref>) 是一种格式化日期/时间输出的更加灵活的方式.</p>
   </section>

   <section id="datatype-timezones">
    <title>时区</title>

    

   <p>时区和时区转换，不仅仅是地理位置问题，也受政治决定影响. 从 1900 年以来，世界上的时区稍微标准了一点, 但还是在持续的改变, 尤其是夏令时规则.
     Greenplum 使用广泛采纳的 IANA (Olson) 时区数据库来定义历史时区规则. 对于未来时间, 假定给定时区的现行已知规则会无限期持续.</p>

    <p>Greenplum 保持与 SQL 标准兼容的典型用法定义.
     然而, SQL 标准偶尔也有一点混淆时间和日期类型和能力. 两个明显的问题是: <ol>
      <li>Although the <codeph>date</codeph> type cannot have an associated time zone, the
        <codeph>time</codeph> type can. Time zones in the real world have little meaning unless
       associated with a date as well as a time, since the offset can vary through the year with
       daylight-saving time boundaries. </li>
      <li>The default time zone is specified as a constant numeric offset from UTC. It is therefore
       impossible to adapt to daylight-saving time when doing date/time arithmetic across DST
       boundaries. </li>
     </ol></p>

    <p>To address these difficulties, we recommend using date/time types that contain both date and
     time when using time zones. We do <i>not</i> recommend using the type <codeph>time with time
      zone</codeph> (though it is supported by Greenplum for legacy applications and for compliance
     with the SQL standard). Greenplum assumes your local time zone for any type containing only
     date or time.</p>

    <p>All timezone-aware dates and times are stored internally in UTC. They are converted to local
     time in the zone specified by the <codeph>TimeZone</codeph> configuration parameter before
     being displayed to the client.</p>

    <p>Greenplum allows you to specify time zones in three different forms: <ol>
      <li>A full time zone name, for example <codeph>America/New_York</codeph>. The recognized time
       zone names are listed in the <codeph>pg_timezone_names</codeph> view. Greenplum uses the
       widely-used IANA time zone data for this purpose, so the same time zone names are also
       recognized by much other software. </li>
      <li>A time zone abbreviation, for example <codeph>PST</codeph>. Such a specification merely
       defines a particular offset from UTC, in contrast to full time zone names which can imply a
       set of daylight savings transition-date rules as well. The recognized abbreviations are
       listed in the <codeph>pg_timezone_abbrevs</codeph> view. You cannot set the configuration
       parameters <xref href="config_params/guc-list.xml#TimeZone"/> or <xref
        href="config_params/guc-list.xml#log_timezone"/> to a time zone abbreviation, but you can
       use abbreviations in date/time input values and with the <codeph>AT TIME ZONE</codeph>
       operator. </li>
      <li>In addition to the timezone names and abbreviations, Greenplum will accept POSIX-style
       time zone specifications of the form <varname>STD</varname><varname>offset</varname> or
        <varname>STD</varname><varname>offset</varname><varname>DST</varname>, where
        <varname>STD</varname> is a zone abbreviation, <varname>offset</varname> is a numeric offset
       in hours west from UTC, and <varname>DST</varname> is an optional daylight-savings zone
       abbreviation, assumed to stand for one hour ahead of the given offset. For example, if
        <codeph>EST5EDT</codeph> were not already a recognized zone name, it would be accepted and
       would be functionally equivalent to United States East Coast time. In this syntax, a zone
       abbreviation can be a string of letters, or an arbitrary string surrounded by angle brackets
        (<codeph>&lt;&gt;</codeph>). When a daylight-savings zone abbreviation is present, it is
       assumed to be used according to the same daylight-savings transition rules used in the IANA
       time zone database's entry. In a standard Greenplum installation, is the same as
        <codeph>US/Eastern</codeph>, so that POSIX-style time zone specifications follow USA
       daylight-savings rules. If needed, you can adjust this behavior by replacing the file. </li>
     </ol> In short, this is the difference between abbreviations and full names: abbreviations
     represent a specific offset from UTC, whereas many of the full names imply a local
     daylight-savings time rule, and so have two possible UTC offsets. As an example,
      <codeph>2014-06-04 12:00 America/New_York</codeph> represents noon local time in New York,
     which for this particular date was Eastern Daylight Time (UTC-4). So <codeph>2014-06-04 12:00
      EDT</codeph> specifies that same time instant. But <codeph>2014-06-04 12:00 EST</codeph>
     specifies noon Eastern Standard Time (UTC-5), regardless of whether daylight savings was
     nominally in effect on that date.</p>

    <p>To complicate matters, some jurisdictions have used the same timezone abbreviation to mean
     different UTC offsets at different times; for example, in Moscow <codeph>MSK</codeph> has meant
     UTC+3 in some years and UTC+4 in others. Greenplum interprets such abbreviations according to
     whatever they meant (or had most recently meant) on the specified date; but, as with the
      <codeph>EST</codeph> example above, this is not necessarily the same as local civil time on
     that date.</p>

    <p>One should be wary that the POSIX-style time zone feature can lead to silently accepting
     bogus input, since there is no check on the reasonableness of the zone abbreviations. For
     example, <codeph>SET TIMEZONE TO FOOBAR0</codeph> will work, leaving the system effectively
     using a rather peculiar abbreviation for UTC. Another issue to keep in mind is that in POSIX
     time zone names, positive offsets are used for locations of Greenwich. Everywhere else,
     Greenplum follows the ISO-8601 convention that positive timezone offsets are of Greenwich.</p>

    <p>In all cases, timezone names and abbreviations are recognized case-insensitively.</p>

    <p>Neither timezone names nor abbreviations are hard-wired into the server; they are obtained
     from configuration files <ph otherprops="pivotal"> (see <xref
       href="../install_guide/localization.xml" scope="peer">Configuring Localization
       Settings</xref>)</ph>.</p>

    <p>The <codeph>TimeZone</codeph> configuration parameter can be set in the file , or in any of
     the other standard ways for setting configuration parameters. There are also some special ways
     to set it: <ol>
      <li>The SQL command <codeph>SET TIME ZONE</codeph> sets the time zone for the session. This is
       an alternative spelling of <codeph>SET TIMEZONE TO</codeph> with a more SQL-spec-compatible
       syntax. </li>
      <li>The <codeph>PGTZ</codeph> environment variable is used by <codeph>libpq</codeph> clients
       to send a <codeph>SET TIME ZONE</codeph> command to the server upon connection. </li>
     </ol></p>
   </section>

   <section id="datatype-interval-input">
    <title>Interval Input</title>

     <p><codeph>interval</codeph> values can be written using the following verbose syntax:
     <codeblock>
<varname>@</varname> <varname>quantity</varname> <varname>unit</varname> <varname>quantity</varname> <varname>unit</varname>... <varname>direction</varname>
</codeblock>
     where <varname>quantity</varname> is a number (possibly signed); <varname>unit</varname> is
      <codeph>microsecond</codeph>, <codeph>millisecond</codeph>, <codeph>second</codeph>,
      <codeph>minute</codeph>, <codeph>hour</codeph>, <codeph>day</codeph>, <codeph>week</codeph>,
      <codeph>month</codeph>, <codeph>year</codeph>, <codeph>decade</codeph>,
      <codeph>century</codeph>, <codeph>millennium</codeph>, or abbreviations or plurals of these
     units; <varname>direction</varname> can be <codeph>ago</codeph> or empty. The at sign
      (<codeph>@</codeph>) is optional noise. The amounts of the different units are implicitly
     added with appropriate sign accounting. <codeph>ago</codeph> negates all the fields. This
     syntax is also used for interval output, if <xref
      href="config_params/guc-list.xml#IntervalStyle"/> is set to <codeph>postgres_verbose</codeph>.</p>

    <p>Quantities of days, hours, minutes, and seconds can be specified without
     explicit unit markings.  For example, <codeph>'1 12:59:10'</codeph> is read
     the same as <codeph>'1 day 12 hours 59 min 10 sec'</codeph>.  Also,
     a combination of years and months can be specified with a dash;
     for example <codeph>'200-10'</codeph> is read the same as <codeph>'200 years
     10 months'</codeph>.  (These shorter forms are in fact the only ones allowed
     by the SQL standard, and are used for output when
     <varname>IntervalStyle</varname> is set to <codeph>sql_standard</codeph>.)</p>

    <p>Interval values can also be written as ISO 8601 time intervals, using either the
      <codeph>format with designators</codeph> of the standard's section 4.4.3.2 or the
      <codeph>alternative format</codeph> of section 4.4.3.3. The format with designators looks like
     this:
     <codeblock>
P <varname>quantity</varname> <varname>unit</varname> <varname>quantity</varname> <varname>unit</varname> ...  T  <varname>quantity</varname> <varname>unit</varname> ...
</codeblock>
     The string must start with a <codeph>P</codeph>, and may include a <codeph>T</codeph> that
     introduces the time-of-day units. The available unit abbreviations are given in <xref
      href="#topic_abq_gfk_qfb/datatype-interval-iso8601-units" format="dita"/>. Units may be
     omitted, and may be specified in any order, but units smaller than a day must appear after
      <codeph>T</codeph>. In particular, the meaning of <codeph>M</codeph> depends on whether it is
     before or after <codeph>T</codeph>.</p>

     <table id="datatype-interval-iso8601-units">
      <title>ISO 8601 Interval Unit Abbreviations</title>
     <tgroup cols="2">
       <thead>
        <row>
         <entry>Abbreviation</entry>
         <entry>Meaning</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Y</entry>
         <entry>Years</entry>
        </row>
        <row>
         <entry>M</entry>
         <entry>Months (in the date part)</entry>
        </row>
        <row>
         <entry>W</entry>
         <entry>Weeks</entry>
        </row>
        <row>
         <entry>D</entry>
         <entry>Days</entry>
        </row>
        <row>
         <entry>H</entry>
         <entry>Hours</entry>
        </row>
        <row>
         <entry>M</entry>
         <entry>Minutes (in the time part)</entry>
        </row>
        <row>
         <entry>S</entry>
         <entry>Seconds</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

     <p>In the alternative format:
<codeblock>
P  <varname>years</varname>-<varname>months</varname>-<varname>days</varname>   T <varname>hours</varname>:<varname>minutes</varname>:<varname>seconds</varname> 
</codeblock>
      the string must begin with <codeph>P</codeph>, and a
      <codeph>T</codeph> separates the date and time parts of the interval.
      The values are given as numbers similar to ISO 8601 dates.</p>

    <p>When writing an interval constant with a <varname>fields</varname>
     specification, or when assigning a string to an interval column that was
     defined with a <varname>fields</varname> specification, the interpretation of
     unmarked quantities depends on the <varname>fields</varname>.  For
     example <codeph>INTERVAL '1' YEAR</codeph> is read as 1 year, whereas
     <codeph>INTERVAL '1'</codeph> means 1 second.  Also, field values
     <codeph>to the right</codeph> of the least significant field allowed by the
     <varname>fields</varname> specification are silently discarded.  For
     example, writing <codeph>INTERVAL '1 day 2:03:04' HOUR TO MINUTE</codeph>
     results in dropping the seconds field, but not the day field.</p>

    <p>According to the SQL standard all fields of an interval value must have the same sign, so a
     leading negative sign applies to all fields; for example the negative sign in the interval
     literal <codeph>'-1 2:03:04'</codeph> applies to both the days and hour/minute/second parts.
     Greenplum allows the fields to have different signs, and traditionally treats each field in the
     textual representation as independently signed, so that the hour/minute/second part is
     considered positive in this example. If <varname>IntervalStyle</varname> is set to
      <codeph>sql_standard</codeph> then a leading sign is considered to apply to all fields (but
     only if no additional signs appear). Otherwise the traditional Greenplum interpretation is
     used. To avoid ambiguity, it's recommended to attach an explicit sign to each field if any
     field is negative.</p>

    <p>In the verbose input format, and in some fields of the more compact
     input formats, field values can have fractional parts; for example
     <codeph>'1.5 week'</codeph> or <codeph>'01:02:03.45'</codeph>.  Such input is
     converted to the appropriate number of months, days, and seconds
     for storage.  When this would result in a fractional number of
     months or days, the fraction is added to the lower-order fields
     using the conversion factors 1 month = 30 days and 1 day = 24 hours.
     For example, <codeph>'1.5 month'</codeph> becomes 1 month and 15 days.
     Only seconds will ever be shown as fractional on output.</p>

    <p><xref href="#topic_abq_gfk_qfb/datatype-interval-input-examples" format="dita"/> shows some
     examples of valid <codeph>interval</codeph> input.</p>

     <table id="datatype-interval-input-examples">
      <title>Interval Input</title>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Example</entry>
         <entry>Description</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>1-2</entry>
         <entry>SQL standard format: 1 year 2 months</entry>
        </row>
        <row>
         <entry>3 4:05:06</entry>
         <entry>SQL standard format: 3 days 4 hours 5 minutes 6 seconds</entry>
        </row>
        <row>
         <entry>1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
         <entry>Traditional Postgres format: 1 year 2 months 3 days 4 hours 5 minutes 6 seconds</entry>
        </row>
        <row>
         <entry>P1Y2M3DT4H5M6S</entry>
         <entry>ISO 8601 <codeph>format with designators</codeph>: same meaning as above</entry>
        </row>
        <row>
         <entry>P0001-02-03T04:05:06</entry>
         <entry>ISO 8601 <codeph>alternative format</codeph>: same meaning as above</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <p>Internally <codeph>interval</codeph> values are stored as months, days,
     and seconds. This is done because the number of days in a month
     varies, and a day can have 23 or 25 hours if a daylight savings
     time adjustment is involved.  The months and days fields are integers
     while the seconds field can store fractions.  Because intervals are
     usually created from constant strings or <codeph>timestamp</codeph> subtraction,
     this storage method works well in most cases, but can cause unexpected
     results:

<codeph>
SELECT EXTRACT(hours from '80 minutes'::interval);
 date_part
-----------
         1

SELECT EXTRACT(days from '80 hours'::interval);
 date_part
-----------
         0
</codeph>

     Functions <codeph>justify_days</codeph> and
     <codeph>justify_hours</codeph> are available for adjusting days
     and hours that overflow their normal ranges.</p>

   </section>

   <section id="datatype-interval-output">
    <title>Interval Output</title>


    <p>The output format of the interval type can be set to one of the four styles
      <codeph>sql_standard</codeph>, <codeph>postgres</codeph>, <codeph>postgres_verbose</codeph>,
     or <codeph>iso_8601</codeph>, using the command <codeph>SET intervalstyle</codeph>. The default
     is the <codeph>postgres</codeph> format. <xref
      href="#topic_abq_gfk_qfb/interval-style-output-table" format="dita"/> shows examples of each
     output style.</p>

    <p>The <codeph>sql_standard</codeph> style produces output that conforms to
     the SQL standard's specification for interval literal strings, if
     the interval value meets the standard's restrictions (either year-month
     only or day-time only, with no mixing of positive
     and negative components).  Otherwise the output looks like a standard
     year-month literal string followed by a day-time literal string,
     with explicit signs added to disambiguate mixed-sign intervals.</p>

    <p>The output of the <codeph>postgres</codeph> style matches the output of PostgreSQL releases
     prior to 8.4 when the <xref href="config_params/guc-list.xml#DateStyle"/> parameter was set to
      <codeph>ISO</codeph>.</p>

    <p>The output of the <codeph>postgres_verbose</codeph> style matches the output of
     PostgreSQL releases prior to 8.4 when the
     <varname>DateStyle</varname> parameter was set to non-<codeph>ISO</codeph> output.</p>

    <p>The output of the <codeph>iso_8601</codeph> style matches the <codeph>format
     with designators</codeph> described in section 4.4.3.2 of the
     ISO 8601 standard.</p>

     <table id="interval-style-output-table">
       <title>Interval Output Style Examples</title>
       <tgroup cols="4">
        <thead>
         <row>
          <entry>Style Specification</entry>
          <entry>Year-Month Interval</entry>
          <entry>Day-Time Interval</entry>
          <entry>Mixed Interval</entry>
         </row>
        </thead>
        <tbody>
         <row>
          <entry><codeph>sql_standard</codeph></entry>
          <entry>1-2</entry>
          <entry>3 4:05:06</entry>
          <entry>-1-2 +3 -4:05:06</entry>
         </row>
         <row>
          <entry><codeph>postgres</codeph></entry>
          <entry>1 year 2 mons</entry>
          <entry>3 days 04:05:06</entry>
          <entry>-1 year -2 mons +3 days -04:05:06</entry>
         </row>
         <row>
          <entry><codeph>postgres_verbose</codeph></entry>
          <entry>@ 1 year 2 mons</entry>
          <entry>@ 3 days 4 hours 5 mins 6 secs</entry>
          <entry>@ 1 year 2 mons -3 days 4 hours 5 mins 6 secs ago</entry>
         </row>
         <row>
          <entry><codeph>iso_8601</codeph></entry>
          <entry>P1Y2M</entry>
          <entry>P3DT4H5M6S</entry>
          <entry>P-1Y-2M3DT-4H-5M-6S</entry>
         </row>
        </tbody>
       </tgroup>
    </table>

   </section>
    </body>
  </topic>
</dita>
