<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Composite//EN" "ditabase.dtd">
<topic id="topic1" xml:lang="en">
  <title id="ih135496">内置函数摘要</title>
  <abstract>Greenplum数据库支持内置函数和运算符，包括可用于窗口表达式的分析函数和窗口函数。
    有关使用内置Greenplum数据库函数的信息，请参阅<cite>Greenplum数据库管理员指南</cite>中的“使用函数和运算符”。
    </abstract>
  <body>
    <p>
      <ul id="ul_tpq_zwq_kr">
        <li>
          <xref href="#topic27" format="dita"/>
        </li>
        <li>
          <xref format="dita" href="#topic29" type="topic"/>
        </li>
        <li>
          <xref href="#topic_gn4_x3w_mq" format="dita"/></li>
        <li>
          <xref format="dita" href="#topic30" type="topic"/>
        </li>
        <li>
          <xref format="dita" href="#topic31" type="topic"/>
        </li>
        <li><xref href="#topic_vpj_ss1_lfb" format="dita"/></li>
        <li><xref href="#functions-range" format="dita"/></li>
      </ul>
    </p>
  </body>
  <topic id="topic27" xml:lang="en">
    <title id="in201560">Greenplum数据库函数类型</title>
    <body>
      <p>Greenplum数据库评估SQL表达式中使用的函数和运算符。
        某些函数和运算符只允许在master服务器上执行，因为它们可能导致Greenplum数据库segment实例中的不一致。
        该表描述了Greenplum数据库函数类型。
        </p>
      <table id="in201681">
        <title>Greenplum数据库中的函数</title>
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="77*"/>
          <colspec colname="col2" colnum="2" colwidth="86*"/>
          <colspec colname="col3" colnum="3" colwidth="144*"/>
          <colspec colname="col4" colnum="4" colwidth="144*"/>
          <thead>
            <row>
              <entry colname="col1">函数类型</entry>
              <entry colname="col2">Greenplum是否支持</entry>
              <entry colname="col3">描述</entry>
              <entry colname="col4">注释</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">IMMUTABLE</entry>
              <entry colname="col2">是</entry>
              <entry colname="col3">仅依赖于其参数列表中的信息。给定相同的参数值，始终返回相同的结果。</entry>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">STABLE</entry>
              <entry colname="col2">在大多数情况下是的</entry>
              <entry colname="col3">在单个表扫描中，对相同的参数值返回相同的结果，但结果将通过SQL语句进行更改。</entry>
              <entry colname="col4">结果取决于数据库查找或参数值。
                <codeph>current_timestamp</codeph>系列函数是<codeph>STABLE</codeph>; 值在执行中不会改变。
                </entry>
            </row>
            <row>
              <entry colname="col1">VOLATILE</entry>
              <entry colname="col2">受限制的</entry>
              <entry colname="col3">函数值可以在单个表扫描中更改。例如: <codeph>random()</codeph>, <codeph>timeofday()</codeph>。
                </entry>
              <entry colname="col4">任何具有副作用的函数都是易变的，即使其结果是可预测的。
                例如：<codeph>setval()</codeph>。</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <p>在Greenplum数据库中，数据跨segment分割 - 每个segment是不同的PostgreSQL数据库。
        为了防止出现不一致或意外的结果，如果它们包含SQL命令或以任何方式修改数据库，则不要在segment级别执行归类为<codeph>VOLATILE</codeph>的函数。
        例如，不允许在Greenplum数据库中对分布式数据执行诸如<codeph>setval()</codeph>之类的函数，因为它们可能导致segment实例之间的数据不一致。
        </p>
      <p>为确保数据一致性，可以在master服务器上评估和运行的语句中安全地使用<codeph>VOLATILE</codeph>和<codeph>STABLE</codeph>函数。
        例如，以下语句在master上运行（没有<codeph>FROM</codeph>子句的语句）：
        </p>
      <p>
        <codeblock>SELECT setval('myseq', 201);
SELECT foo();
</codeblock>
      </p>
      <p>如果语句具有包含分布式表的<codeph>FROM</codeph>子句，并且<codeph>FROM</codeph>子句中的函数返回一组行，则该语句可以在segment上运行：
        </p>
      <p>
        <codeblock>SELECT * from foo();
</codeblock>
      </p>
      <p>Greenplum数据库不支持返回表引用（<codeph>rangeFuncs</codeph>）的函数或使用<codeph>refCursor</codeph>数据类型的函数。
        </p>
    </body>
  </topic>
  <topic id="topic29" xml:lang="en">
    <title id="in141007">内置函数和运算符</title>
    <body>
      <p>下表列出了PostgreSQL支持的内置函数和运算符的类别。
        Greenplum数据库支持所有函数和运算符，如PostgreSQL，但<codeph>STABLE</codeph>和<codeph>VOLATILE</codeph>函数除外，它们受<xref href="#topic27" format="dita"/>中的限制。
        有关这些内置函数和运算符的更多信息，请参阅PostgreSQL文档的<xref format="html" href="https://www.postgresql.org/docs/9.4/functions.html"
                                                scope="external">函数和运算符</xref>部分。
        </p>
      <table id="in204913">
        <title>内置函数和运算符</title>
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="129.02*"/>
          <colspec colname="col2" colnum="2" colwidth="108*"/>
          <colspec colname="col3" colnum="3" colwidth="144*"/>
          <colspec colname="col4" colnum="4" colwidth="86*"/>
          <thead>
            <row>
              <entry colname="col1">操作符/函数类别</entry>
              <entry colname="col2">VOLATILE函数</entry>
              <entry colname="col3">STABLE函数</entry>
              <entry colname="col4">限制</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-logical.html" scope="external"
                  >逻辑操作符</xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-comparison.html"
                  scope="external">比较操作符</xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.4/functions-math.html"
                  scope="external">
                  <ph>数学函数和操作符</ph>
                </xref>
              </entry>
              <entry colname="col2">random<p>setseed</p></entry>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.4/functions-string.html"
                  scope="external">
                  <ph>字符串函数和操作符</ph>
                </xref>
              </entry>
              <entry colname="col2">
                <i>所有内建转换函数</i>
              </entry>
              <entry colname="col3">convert<p>pg_client_encoding</p></entry>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-binarystring.html"
                  scope="external">
                  <ph>二进制字符串和函数操作符</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-bitstring.html"
                  scope="external">
                  <ph>位串函数和操作符</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-matching.html"
                  scope="external">
                  <ph>模式匹配</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-formatting.html"
                  scope="external">
                  <ph>数据类型格式函数</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3">to_char<p>to_timestamp</p></entry>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-datetime.html"
                  scope="external">
                  <ph>日期/时间函数和操作符</ph>
                </xref>
              </entry>
              <entry colname="col2">timeofday</entry>
              <entry colname="col3"
                  >age<p>current_date</p><p>current_time</p><p>current_timestamp</p><p>localtime</p><p>localtimestamp</p><p>now</p></entry>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.4/functions-enum.html"
                  scope="external">枚举支持函数</xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-geometry.html"
                  scope="external">
                  <ph>几何函数和操作符</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.4/functions-net.html"
                  scope="external">
                  <ph>网络地址函数和操作符</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-sequence.html"
                  scope="external">
                  <ph>序列操作函数</ph>
                </xref>
              </entry>
              <entry colname="col2">nextval()<p>setval()</p></entry>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-conditional.html"
                  scope="external">
                  <ph>条件表达式</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.4/functions-array.html"
                  scope="external">
                  <ph>数组函数和操作符</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3">
                <i>所有数组函数</i>
              </entry>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-aggregate.html"
                  scope="external">
                  <ph>聚合函数</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-subquery.html"
                  scope="external">
                  <ph>子查询表达式</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html"
                  href="https://www.postgresql.org/docs/9.4/functions-comparisons.html"
                  scope="external">
                  <ph>行和数组比较</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.4/functions-srf.html"
                  scope="external">
                  <ph>返回集合函数</ph>
                </xref>
              </entry>
              <entry colname="col2">generate_series</entry>
              <entry colname="col3"/>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.4/functions-info.html"
                  scope="external">
                  <ph>系统信息函数</ph>
                </xref>
              </entry>
              <entry colname="col2"/>
              <entry colname="col3">
                <i>所有会话信息函数</i>
                <p>
                  <i>所有访问特权查询函数</i>
                </p><p>
                  <i>所有模式可见性查询函数</i>
                </p><p>
                  <i>所有系统目录信息函数</i>
                </p><p>
                  <i>所有注释信息函数</i>
                </p><p>
                  <i>所有事务ID和快照</i>
                </p></entry>
              <entry colname="col4"/>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.4/functions-admin.html"
                  scope="external">
                  <ph>系统管理函数</ph>
                </xref>
              </entry>
              <entry colname="col2"
                  >set_config<p>pg_cancel_backend</p><p>pg_reload_conf</p><p>pg_rotate_logfile</p><p>pg_start_backup</p><p>pg_stop_backup</p><p>pg_size_pretty</p><p>pg_ls_dir</p><p>pg_read_file</p><p>pg_stat_file</p></entry>
              <entry colname="col3">current_setting<p><i>所有数据库对象尺寸函数</i></p></entry>
              <entry colname="col4"><b>注意：</b> 函数<codeph>pg_column_size</codeph>显示存储值所需的字节，可能使用TOAST压缩。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <xref format="html" href="https://www.postgresql.org/docs/9.1/functions-xml.html"
                  scope="external">XML函数</xref>和类似函数的表达式</entry>
              <entry colname="col2"/>
              <entry colname="col3">
                <p>cursor_to_xml(cursor refcursor, count int, nulls boolean, tableforest boolean,
                  targetns text)</p>
                <p>cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean,
                  targetns text)</p>
                <p>database_to_xml(nulls boolean, tableforest boolean, targetns text)</p>
                <p>database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)</p>
                <p>database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns
                  text)</p>
                <p>query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)</p>
                <p>query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns
                  text)</p>
                <p>query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean,
                  targetns text)</p>
                <p>schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns text)</p>
                <p>schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, targetns
                  text)</p>
                <p>schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean,
                  targetns text)</p>
                <p>table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns text)</p>
                <p>table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, targetns
                  text)</p>
                <p>table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean,
                  targetns text)</p>
                <p>xmlagg(xml)</p>
                <p>xmlconcat(xml[, ...])</p>
                <p>xmlelement(name name [, xmlattributes(value [AS attname] [, ... ])] [, content,
                  ...])</p>
                <p>xmlexists(text, xml)</p>
                <p>xmlforest(content [AS name] [, ...])</p>
                <p>xml_is_well_formed(text)</p>
                <p>xml_is_well_formed_document(text)</p>
                <p>xml_is_well_formed_content(text)</p>
                <p>xmlparse ( { DOCUMENT | CONTENT } value)</p>
                <p>xpath(text, xml)</p>
                <p>xpath(text, xml, text[])</p>
                <p>xpath_exists(text, xml)</p>
                <p>xpath_exists(text, xml, text[])</p>
                <p>xmlpi(name target [, content])</p>
                <p>xmlroot(xml, version text | no value [, standalone yes|no|no value])</p>
                <p>xmlserialize ( { DOCUMENT | CONTENT } value AS type )</p>
                <p>xml(text)</p>
                <p>text(xml)</p>
                <p>xmlcomment(xml)</p>
                <p>xmlconcat2(xml, xml)</p>
              </entry>
              <entry colname="col4"/>
            </row>
          </tbody>
        </tgroup>
      </table>
    </body>
  </topic>
  <topic id="topic_gn4_x3w_mq">
    <title>JSON函数和操作符</title>
    <body>
      <p>Greenplum数据库包含用于创建和操作JSON数据的内置函数和运算符。
        <ul id="ul_ypx_f4w_2z">
          <li><xref href="#topic_o5y_14w_2z" format="dita"/></li>
          <li><xref href="#topic_u4s_wnw_2z" format="dita"/></li>
          <li><xref href="#topic_rvp_lk3_sfb" format="dita"/></li>
          <li><xref href="#topic_z5d_snw_2z" format="dita"/></li>
        </ul></p>
      <note>对于<codeph>json</codeph>数据类型值，即使JSON对象包含重复键，也会保留所有键/值对。
        对于重复键，JSON处理函数将最后一个值视为可操作的值。
        对于<codeph>jsonb</codeph>数据类型，不保留重复的对象键。
        如果输入包含重复键，则仅保留最后一个值。
        参考
          <xref href="../admin_guide/query/topics/json-data.xml#topic_upc_tcs_fz" format="dita"/><ph
          otherprops="op-print"> in the <cite>Greenplum Database Administrator
        Guide</cite></ph>。</note>
    </body>
    <topic id="topic_o5y_14w_2z">
      <title>JSON操作符</title>
      <body>
        <p>此表描述了可用于<codeph>json</codeph>和<codeph>jsonb</codeph>数据类型的运算符。
          </p>
        <table id="table_e41_y3w_mq">
          <title><varname>json</varname>和<codeph>jsonb</codeph>操作符</title>
          <tgroup cols="5">
            <colspec colnum="1" colname="col1" colwidth="1*"/>
            <colspec colnum="2" colname="col2" colwidth="1.17*"/>
            <colspec colnum="3" colname="col3" colwidth="2.79*"/>
            <colspec colnum="4" colname="col4" colwidth="2.78*"/>
            <colspec colnum="5" colname="col5" colwidth="1.92*"/>
            <thead>
              <row>
                <entry>操作符</entry>
                <entry>右操作数类型</entry>
                <entry>描述</entry>
                <entry>示例</entry>
                <entry>示例结果</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>-></codeph>
                </entry>
                <entry>
                  <codeph>int</codeph>
                </entry>
                <entry>获取JSON数组元素（从零索引）。</entry>
                <entry>
                  <codeph>'[{"a":"foo"},{"b":"bar"},{"c":"baz"}]'::json->2</codeph>
                </entry>
                <entry>
                  <codeph>{"c":"baz"}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>-></codeph>
                </entry>
                <entry>
                  <codeph>text</codeph>
                </entry>
                <entry>通过键获取JSON对象字段。</entry>
                <entry>
                  <codeph>'{"a": {"b":"foo"}}'::json->'a'</codeph>
                </entry>
                <entry>
                  <codeph>{"b":"foo"}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>->></codeph>
                </entry>
                <entry>
                  <codeph>int</codeph>
                </entry>
                <entry>获取JSON数组元素作为<codeph>text</codeph>。</entry>
                <entry>
                  <codeph>'[1,2,3]'::json->>2</codeph>
                </entry>
                <entry>
                  <codeph>3</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>->></codeph>
                </entry>
                <entry>
                  <codeph>text</codeph>
                </entry>
                <entry>获取JSON对象字段作为<codeph>text</codeph>。</entry>
                <entry>
                  <codeph>'{"a":1,"b":2}'::json->>'b'</codeph>
                </entry>
                <entry>
                  <codeph>2</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>#></codeph>
                </entry>
                <entry>
                  <codeph>text[]</codeph>
                </entry>
                <entry>在指定的路径获取JSON对象。</entry>
                <entry><codeph>'{"a": {"b":{"c": "foo"}}}'::json#>'{a,b}</codeph>'</entry>
                <entry>
                  <codeph>{"c": "foo"}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>#>></codeph>
                </entry>
                <entry>
                  <codeph>text[]</codeph>
                </entry>
                <entry>以指定路径获取JSON对象作为<codeph>text</codeph>。</entry>
                <entry>
                  <codeph>'{"a":[1,2,3],"b":[4,5,6]}'::json#>>'{a,2}'</codeph>
                </entry>
                <entry>
                  <codeph>3</codeph>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note>对于<codeph>json</codeph>和<codeph>jsonb</codeph>数据类型，这些运算符都有并行变体。
          字段，元素和路径提取运算符返回与其左侧输入（<codeph>json</codeph>或<codeph>jsonb</codeph>）相同的数据类型，但指定为返回<codeph>text</codeph>的那些除外，它将值强制转换为<codeph>text</codeph>。
          如果JSON输入没有与请求匹配的正确结构，则字段，元素和路径提取操作符将返回<codeph>NULL</codeph>，而不是失败; 例如，如果不存在这样的元素。
          </note>
        <p>需要<codeph>jsonb</codeph>数据类型作为左操作数的运算符如下表所述。
          其中许多运算符可以由<codeph>jsonb</codeph>运算符类索引。
          有关<codeph>jsonb</codeph>包含和存在语义的完整描述，请参阅<xref
                  href="../admin_guide/query/topics/json-data.xml#topic_isx_2tw_mq" format="dita"/>。
          有关如何使用这些运算符有效地索引<codeph>jsonb</codeph>数据的信息，请参阅<xref
                  href="../admin_guide/query/topics/json-data.xml#topic_aqt_1tw_mq" format="dita"/>
          <ph
            otherprops="op-print"> in the <cite>Greenplum Database Administrator
          Guide</cite></ph>。</p>
        <table id="table_dcb_y3w_mq">
          <title><codeph>jsonb</codeph>操作符</title>
          <tgroup cols="4">
            <colspec colnum="1" colname="col1" colwidth="1*"/>
            <colspec colnum="2" colname="col2" colwidth="1.94*"/>
            <colspec colnum="3" colname="col3" colwidth="4.59*"/>
            <colspec colnum="4" colname="col4" colwidth="2.5*"/>
            <thead>
              <row>
                <entry>操作符</entry>
                <entry>右操作数类型</entry>
                <entry>描述</entry>
                <entry>示例</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>@></codeph>
                </entry>
                <entry>
                  <codeph>jsonb</codeph>
                </entry>
                <entry>左JSON值是否包含正确的值？</entry>
                <entry>
                  <codeph>'{"a":1, "b":2}'::jsonb @> '{"b":2}'::jsonb</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>&lt;@</codeph>
                </entry>
                <entry>
                  <codeph>jsonb</codeph>
                </entry>
                <entry>左JSON值是否包含在右值内？</entry>
                <entry>
                  <codeph>'{"b":2}'::jsonb &lt;@ '{"a":1, "b":2}'::jsonb</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>?</codeph>
                </entry>
                <entry>
                  <codeph>text</codeph>
                </entry>
                <entry>键/元素字符串是否存在于JSON值中？</entry>
                <entry>
                  <codeph>'{"a":1, "b":2}'::jsonb ? 'b'</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>?|</codeph>
                </entry>
                <entry>
                  <codeph>text[]</codeph>
                </entry>
                <entry>是否存在任何这些键/元素字符串？</entry>
                <entry>
                  <codeph>'{"a":1, "b":2, "c":3}'::jsonb ?| array['b', 'c']</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>?&amp;</codeph>
                </entry>
                <entry>
                  <codeph>text[]</codeph>
                </entry>
                <entry>是否存在所有这些键/元素字符串？</entry>
                <entry>
                  <codeph>'["a", "b"]'::jsonb ?&amp; array['a', 'b']</codeph>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <p>下表中的标准比较运算符仅适用于<codeph>jsonb</codeph>数据类型，不适用于<codeph>json</codeph>数据类型。
          它们遵循<xref
                  href="../admin_guide/query/topics/json-data.xml#topic_aqt_1tw_mq" format="dita"/>中描述的B树操作的排序规则
          <ph
            otherprops="op-print"> in the <cite>Greenplum Database Administrator
          Guide</cite></ph>。</p>
        <table id="table_j4w_z5n_vq">
          <title><codeph>jsonb</codeph>比较操作符</title>
          <tgroup cols="2">
            <colspec colnum="1" colname="col1"/>
            <colspec colnum="2" colname="col2"/>
            <thead>
              <row>
                <entry>操作符</entry>
                <entry>描述</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>&lt;</codeph>
                </entry>
                <entry>小于</entry>
              </row>
              <row>
                <entry>
                  <codeph>></codeph>
                </entry>
                <entry>大于</entry>
              </row>
              <row>
                <entry>
                  <codeph>&lt;=</codeph>
                </entry>
                <entry>小于等于</entry>
              </row>
              <row>
                <entry>
                  <codeph>>=</codeph>
                </entry>
                <entry>大于等于</entry>
              </row>
              <row>
                <entry>
                  <codeph>=</codeph>
                </entry>
                <entry>等于</entry>
              </row>
              <row>
                <entry><codeph>&lt;></codeph>或<codeph>!=</codeph></entry>
                <entry>不等于</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note><codeph>!=</codeph>运算符在解析器阶段转换为<codeph>&lt;></codeph>。
          不可能实现执行不同操作的<codeph>!=</codeph>和<codeph>&lt;></codeph>运算符。
          </note>
      </body>
    </topic>
    <topic id="topic_u4s_wnw_2z">
      <title>JSON创建函数</title>
      <body>
        <p>此表描述了创建<codeph>json</codeph>数据类型值的函数。
          （目前，<codeph>jsonb</codeph>没有等效函数，但您可以将其中一个函数的结果转换为<codeph>jsonb</codeph>。）
          </p>
        <table id="table_sqb_y3w_mb">
          <title>JSON创建函数</title>
          <tgroup cols="4">
            <colspec colnum="1" colname="col1"/>
            <colspec colnum="2" colname="col2"/>
            <colspec colnum="3" colname="col3"/>
            <colspec colnum="4" colname="col4"/>
            <thead>
              <row>
                <entry>函数</entry>
                <entry>描述</entry>
                <entry>示例</entry>
                <entry>示例结果</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>to_json(anyelement)</codeph>
                </entry>
                <entry>以JSON对象的形式返回值。
                  数组和复合体以递归方式处理，并转换为数组和对象。
                  如果输入包含从类型到<codeph>json</codeph>的强制转换，则使用强制转换函数执行转换; 否则，将生成JSON标量值。
                  对于除数字，布尔值或空值之外的任何标量类型，将使用正确引用和转义文本表示，以使其成为有效的JSON字符串。
                  </entry>
                <entry>
                  <codeph>to_json('Fred said "Hi."'::text)</codeph>
                </entry>
                <entry>
                  <codeph>"Fred said \"Hi.\""</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>array_to_json(anyarray [, pretty_bool])</codeph>
                </entry>
                <entry>将数组作为JSON数组返回。
                  多维数组成为数组的JSON数组。
                  <p>如果<codeph>pretty_bool</codeph>为true，则会在dimension-1元素之间添加换行符。
                    </p>
                </entry>
                <entry>
                  <codeph>array_to_json('{{1,5},{99,100}}'::int[])</codeph>
                </entry>
                <entry>
                  <codeph>[[1,5],[99,100]]</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>row_to_json(record [, pretty_bool])</codeph>
                </entry>
                <entry>将行作为JSON对象返回。
                  <p>如果<codeph>pretty_bool</codeph>为true，则会在level-1元素之间添加换行符。
                    </p>
                </entry>
                <entry>
                  <codeph>row_to_json(row(1,'foo'))</codeph>
                </entry>
                <entry>
                  <codeph>{"f1":1,"f2":"foo"}</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_build_array(VARIADIC "any"</codeph>)</entry>
                <entry>从<codeph>VARIADIC</codeph>参数列表构建可能异构类型的JSON数组。
                  </entry>
                <entry>
                  <codeph>json_build_array(1,2,'3',4,5)</codeph>
                </entry>
                <entry>
                  <codeph>[1, 2, "3", 4, 5]</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>json_build_object(VARIADIC "any")</codeph>
                </entry>
                <entry>从<codeph>VARIADIC</codeph>参数列表中构建JSON对象。
                  参数列表按顺序获取并转换为一组键/值对。
                </entry>
                <entry>
                  <codeph>json_build_object('foo',1,'bar',2)</codeph>
                </entry>
                <entry>
                  <codeph>{"foo": 1, "bar": 2}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>json_object(text[])</codeph>
                </entry>
                <entry>从文本数组中构建JSON对象。
                  该数组必须是一维或二维数组。
                  <p>一维数组必须具有偶数个元素。
                    元素被视为键/值对。
                    </p>
                  <p>对于二维数组，每个内部数组必须具有恰好两个元素，这些元素被视为键/值对。
                    </p>
                </entry>
                <entry>
                  <p>
                    <codeph>json_object('{a, 1, b, "def", c, 3.5}')</codeph>
                  </p>
                  <p>
                    <codeph>json_object('{{a, 1},{b, "def"},{c, 3.5}}')</codeph>
                  </p>
                </entry>
                <entry>
                  <codeph>{"a": "1", "b": "def", "c": "3.5"}</codeph>
                </entry>
              </row>
              <row>
                <entry>
                  <codeph>json_object(keys text[], values text[])</codeph>
                </entry>
                <entry>从文本数组中构建JSON对象。
                  这种形式的<codeph>json_object</codeph>从两个独立的数组中成对获取键和值。
                  在所有其他方面，它与单参数形式相同。
                  </entry>
                <entry>
                  <codeph>json_object('{a, b}', '{1,2}')</codeph>
                </entry>
                <entry>
                  <codeph>{"a": "1", "b": "2"}</codeph>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note><codeph>array_to_json</codeph>和<codeph>row_to_json</codeph>与<codeph>to_json</codeph>具有相同的行为，
          除了提供漂亮的打印选项。
          为<codeph>to_json</codeph>描述的行为同样适用于由其他JSON创建函数转换的每个单独的值。
          </note>
        <note><xref href="modules/hstore.xml">hstore</xref>扩展具有从<codeph>hstore</codeph>到<codeph>json</codeph>的强制转换，
          因此通过JSON创建函数转换的<codeph>hstore</codeph>值将表示为JSON对象，而不是原始字符串值。
          </note>
      </body>
    </topic>
    <topic id="topic_rvp_lk3_sfb">
      <title>JSON聚合函数</title>
      <body>
        <p>此表显示函数将记录聚合到JSON对象数组和值对聚合到JSON对象
          </p>
        <table id="table_kkr_mk3_sfb">
          <title>JSON聚合函数</title>
          <tgroup cols="4">
            <colspec colnum="1" colname="col1"/>
            <colspec colnum="2" colname="col2"/>
            <colspec colnum="3" colname="col3"/>
            <colspec colnum="4" colname="col4"/>
            <thead>
              <row>
                <entry>函数</entry>
                <entry>参数类型</entry>
                <entry>返回类型</entry>
                <entry>描述</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>json_agg(record)</codeph>
                </entry>
                <entry>
                  <codeph>record</codeph>
                </entry>
                <entry>
                  <codeph>json</codeph>
                </entry>
                <entry>将记录聚合为JSON对象数组。</entry>
              </row>
              <row>
                <entry>
                  <codeph>json_object_agg(name, value)</codeph>
                </entry>
                <entry>
                  <codeph>("any", "any")</codeph>
                </entry>
                <entry>
                  <codeph>json</codeph>
                </entry>
                <entry>将名称/值对聚合为JSON对象。</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </body>
    </topic>
    <topic id="topic_z5d_snw_2z">
      <title>JSON处理函数</title>
      <body>
        <p>此表显示可用于处理<codeph>json</codeph>和<codeph>jsonb</codeph>值的函数。
          </p>
        <p>许多这些处理函数和运算符将JSON字符串中的Unicode转义转换为适当的单个字符。
          如果输入数据类型是<codeph>jsonb</codeph>，则这不是问题，因为转换已经完成。
          但是，对于<codeph>json</codeph>数据类型输入，这可能会导致抛出错误。
          请参阅
            <xref href="../admin_guide/query/topics/json-data.xml#topic_upc_tcs_fz"/><ph
            otherprops="op-print"> in the <cite>Greenplum Database Administrator
          Guide</cite></ph>。</p>
        <table id="table_wfc_y3w_mb">
          <title>JSON处理函</title>
          <tgroup cols="5">
            <colspec colnum="1" colname="col1" colwidth="1.08*"/>
            <colspec colnum="2" colname="col2" colwidth="1*"/>
            <colspec colnum="3" colname="col3" colwidth="1.01*"/>
            <colspec colnum="4" colname="col4" colwidth="1.24*"/>
            <colspec colnum="5" colname="col5" colwidth="1.01*"/>
            <thead>
              <row>
                <entry>函数</entry>
                <entry>返回类型</entry>
                <entry>描述</entry>
                <entry>示例</entry>
                <entry>示例结果</entry>
              </row>
            </thead>
            <tbody>
              <row>
                <entry>
                  <codeph>json_array_length(json)</codeph>
                  <p>
                    <codeph>jsonb_array_length(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>int</codeph>
                </entry>
                <entry>返回最外层JSON数组中的元素数。</entry>
                <entry><codeph>json_array_length('[1,2,3,{"f1":1,"f2":[5,6]},4]')</codeph>
                </entry>
                <entry>
                  <codeph>5</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_each(json)</codeph>
                  <p><codeph>jsonb_each(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof key text, value json</codeph>
                  <p><codeph>setof key text, value jsonb</codeph>
                  </p>
                </entry>
                <entry>将最外层的JSON对象扩展为一组键/值对。</entry>
                <entry><codeph>select * from json_each('{"a":"foo", "b":"bar"}')</codeph>
                </entry>
                <entry>
                  <pre> key | value
-----+-------
 a   | "foo"
 b   | "bar"
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_each_text(json)</codeph>
                  <p><codeph>jsonb_each_text(jsonb)</codeph>
                  </p>
                </entry>
                <entry><codeph>setof key text, value text</codeph>
                </entry>
                <entry>将最外层的JSON对象扩展为一组键/值对。
                  返回的值将是<codeph>text</codeph>类型。
                  </entry>
                <entry><codeph>select * from json_each_text('{"a":"foo", "b":"bar"}')</codeph>
                </entry>
                <entry>
                  <pre> key | value
-----+-------
 a   | foo
 b   | bar
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_extract_path(from_json json, VARIADIC path_elems
                    text[])</codeph>
                  <p><codeph>jsonb_extract_path(from_json jsonb, VARIADIC path_elems
                      text[])</codeph>
                  </p></entry>
                <entry>
                  <p><codeph>json</codeph>
                  </p>
                  <p><codeph>jsonb</codeph>
                  </p>
                </entry>
                <entry>返回<codeph>path_elems</codeph>指向的JSON值（相当于<codeph>#></codeph>运算符）。
                  </entry>
                <entry><codeph>json_extract_path('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4')</codeph>
                </entry>
                <entry>
                  <codeph>{"f5":99,"f6":"foo"}</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_extract_path_text(from_json json, VARIADIC path_elems
                    text[])</codeph>
                  <p><codeph>jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems
                      text[])</codeph>
                  </p></entry>
                <entry><codeph>text</codeph>
                </entry>
                <entry>返回<codeph>path_elems</codeph>指向的JSON值作为文本。
                  相当于<codeph>#>></codeph>运算符。
                  </entry>
                <entry><codeph>json_extract_path_text('{"f2":{"f3":1},"f4":{"f5":99,"f6":"foo"}}','f4',
                    'f6')</codeph>
                </entry>
                <entry>
                  <codeph>foo</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_object_keys(json)</codeph>
                  <p><codeph>jsonb_object_keys(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof text</codeph>
                </entry>
                <entry>返回最外层JSON对象中的键集。</entry>
                <entry><codeph>json_object_keys('{"f1":"abc","f2":{"f3":"a", "f4":"b"}}')</codeph>
                </entry>
                <entry>
                  <pre> json_object_keys
------------------
 f1
 f2
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_populate_record(base anyelement, from_json
                      json)</codeph><p><codeph>jsonb_populate_record(base anyelement, from_json
                      jsonb)</codeph>
                  </p></entry>
                <entry><codeph>anyelement</codeph>
                </entry>
                <entry>将<codeph>from_json</codeph>中的对象扩展为其列与base定义的记录类型匹配的行。
                  见注1<xref href="#topic_z5d_snw_2z/json_proc_1"
                    format="dita">注1</xref>。</entry>
                <entry><codeph>select * from json_populate_record(null::myrowtype,
                    '{"a":1,"b":2}')</codeph>
                </entry>
                <entry>
                  <pre> a | b
---+---
 1 | 2
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_populate_recordset(base anyelement, from_json json)</codeph>
                  <p><codeph>jsonb_populate_recordset(base anyelement, from_json jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof anyelement</codeph>
                </entry>
                <entry>将<codeph>from_json</codeph>中最外层对象的数组扩展为一组行，这些行的列与base定义的记录类型匹配。
                  见<xref
                    href="#topic_z5d_snw_2z/json_proc_1" format="dita">注1</xref>。</entry>
                <entry><codeph>select * from json_populate_recordset(null::myrowtype,
                    '[{"a":1,"b":2},{"a":3,"b":4}]')</codeph>
                </entry>
                <entry>
                  <pre> a | b
---+---
 1 | 2
 3 | 4
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_array_elements(json)</codeph>
                  <p><codeph>jsonb_array_elements(jsonb</codeph>)</p></entry>
                <entry>
                  <p><codeph>setof json</codeph>
                  </p>
                  <p><codeph>setof jsonb</codeph>
                  </p>
                </entry>
                <entry>将JSON数组扩展为一组JSON值。</entry>
                <entry><codeph>select * from json_array_elements('[1,true, [2,false]]')</codeph>
                </entry>
                <entry>
                  <pre>   value
-----------
 1
 true
 [2,false]
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_array_elements_text(json)</codeph>
                  <p><codeph>jsonb_array_elements_text(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof text</codeph>
                </entry>
                <entry>将JSON数组扩展为一组文本值。</entry>
                <entry><codeph>select * from json_array_elements_text('["foo", "bar"]')</codeph>
                </entry>
                <entry>
                  <pre>   value
-----------
 foo
 bar
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_typeof(json)</codeph><p><codeph>jsonb_typeof(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>text</codeph>
                </entry>
                <entry>以文本字符串形式返回最外层JSON值的类型。
                  可能的类型是<codeph>object</codeph>，<codeph>array</codeph>，<codeph>string</codeph>，<codeph>number</codeph>，<codeph>boolean</codeph>和<codeph>null</codeph>。
                  见<xref href="#topic_z5d_snw_2z/json_proc_2" format="dita">注2</xref>
                  </entry>
                <entry><codeph>json_typeof('-123.4')</codeph>
                </entry>
                <entry>
                  <codeph>number</codeph>
                </entry>
              </row>
              <row>
                <entry><codeph>json_to_record(json)</codeph><p><codeph>jsonb_to_record(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>record</codeph>
                </entry>
                <entry>从JSON对象构建任意记录。
                  见<xref href="#topic_z5d_snw_2z/json_proc_1" format="dita">注1</xref>。
                  <p>与返回记录的所有函数一样，调用者必须使用<codeph>AS</codeph>子句显式定义记录的结构。</p>
                  </entry>
                <entry><codeph>select * from json_to_record('{"a":1,"b":[1,2,3],"c":"bar"}') as x(a
                    int, b text, d text)</codeph>
                </entry>
                <entry>
                  <pre> a |    b    | d
---+---------+---
 1 | [1,2,3] |
</pre>
                </entry>
              </row>
              <row>
                <entry><codeph>json_to_recordset(json)</codeph>
                  <p><codeph>jsonb_to_recordset(jsonb)</codeph>
                  </p></entry>
                <entry><codeph>setof record</codeph>
                </entry>
                <entry>从JSON对象数组构建任意记录集请参见<xref
                    href="#topic_z5d_snw_2z/json_proc_1" format="dita">注1</xref>。
                  <p>与返回记录的所有函数一样，调用者必须使用<codeph>AS</codeph>子句显式定义记录的结构。
                    </p></entry>
                <entry><codeph>select * from
                    json_to_recordset('[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]') as x(a int, b
                    text);</codeph>
                </entry>
                <entry>
                  <pre> a |  b
---+-----
 1 | foo
 2 |
</pre>
                </entry>
              </row>
            </tbody>
          </tgroup>
        </table>
        <note id="json_record">
          <ol id="ol_umc_2sg_pfb">
            <li id="json_proc_1">函数<codeph>json_populate_record()</codeph>，
              <codeph>json_populate_recordset()</codeph>，
              <codeph>json_to_record()</codeph>和<codeph>json_to_recordset()</codeph>的示例使用常量。
              但是，典型的用法是引用<codeph>FROM</codeph>子句中的表，并使用其中一个<codeph>json</codeph>或<codeph>jsonb</codeph>列作为函数的参数。
              然后可以在查询的其他部分中引用所提取的键值。
              例如，可以在<codeph>WHERE</codeph>子句和目标列表中引用该值。
              以这种方式提取多个值可以提高性能，而不是使用每个键操作符单独提取它们。
              <p>JSON键与目标行类型中的相同列名匹配。
                这些函数的JSON类型强制转换可能不会产生某些类型的期望值。
                将不会在输出中省略未出现在目标行类型中的JSON字段，并且与任何JSON字段不匹配的目标列将为<codeph>NULL</codeph>。
                </p></li>
            <li id="json_proc_2">不应将<codeph>json_typeof</codeph>函数null返回值<codeph>null</codeph>与SQL NULL混淆。
              调用<codeph>json_typeof('null'::json)</codeph>将返回<codeph>null</codeph>，
              调用<codeph>json_typeof(NULL::json)</codeph>将返回SQL<codeph>NULL</codeph>。
              </li>
          </ol>
        </note>
      </body>
    </topic>
  </topic>
  <topic id="topic30" xml:lang="en">
    <title id="in179666">窗口函数</title>
    <body>
      <p>以下是Greenplum数据库内置窗口函数。
        所有窗口函数都是<i>不可变的</i>。
        有关窗口函数的更多信息，请参阅<cite>Greenplum数据库管理员指南</cite>中的“窗口表达式”。
        </p>
      <table id="in164369">
        <title>窗口函数</title>
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="87.46*"/>
          <colspec colname="col2" colnum="2" colwidth="59*"/>
          <colspec colname="col3" colnum="3" colwidth="180*"/>
          <colspec colname="col4" colnum="4" colwidth="121.77*"/>
          <thead>
            <row>
              <entry colname="col1">函数</entry>
              <entry colname="col2">返回类型</entry>
              <entry colname="col3">完整语法</entry>
              <entry colname="col4">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">
                <codeph>cume_dist()</codeph>
              </entry>
              <entry colname="col2">
                <codeph>double precision</codeph>
              </entry>
              <entry colname="col3">
                <codeph>CUME_DIST() OVER ( [PARTITION BY </codeph>
                <ph>expr</ph>
                <codeph>] ORDER BY </codeph>
                <ph>expr</ph>
                <codeph> )</codeph>
              </entry>
              <entry colname="col4">计算一组值中的值的累积分布。
                具有相等值的行始终评估为相同的累积分布值。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>dense_rank()</codeph>
              </entry>
              <entry colname="col2">
                <codeph>bigint</codeph>
              </entry>
              <entry colname="col3">
                <codeph>DENSE_RANK () OVER ( [PARTITION BY </codeph>
                <ph>expr</ph>
                <codeph>] ORDER BY </codeph>
                <ph>expr</ph>
                <codeph>)</codeph>
              </entry>
              <entry colname="col4">计算有序行组中行的等级而不跳过等级值。
                具有相等值的行被赋予相同的等级值。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>first_value(<i>expr</i>)</codeph>
              </entry>
              <entry colname="col2">与输入<i>expr</i>类型相同</entry>
              <entry colname="col3">
                <codeph>FIRST_VALUE(</codeph>
                <ph>expr</ph>
                <codeph>) OVER ( [PARTITION BY </codeph>
                <ph>expr</ph>
                <codeph>] ORDER BY </codeph>
                <ph>expr</ph>
                <codeph> [ROWS|RANGE </codeph>
                <ph>frame_expr</ph>
                <codeph>] )</codeph>
              </entry>
              <entry colname="col4">返回有序值集中的第一个值。</entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>lag(<i>expr</i> [,<i>offset</i>] [,<i>default</i>])</codeph>
              </entry>
              <entry colname="col2">与输入<i>expr</i>类型相同</entry>
              <entry colname="col3">
                <codeph>LAG(</codeph>
                <i>expr</i>
                <codeph> [,</codeph>
                <i>offset</i>
                <codeph>] [,</codeph>
                <i>default</i>
                <codeph>]) OVER ( [PARTITION BY </codeph>
                <i>expr</i>
                <codeph>] ORDER BY </codeph>
                <i>expr</i>
                <codeph> )</codeph>
              </entry>
              <entry colname="col4">提供对同一个表的多个行的访问，而无需进行自连接。
                给定从查询返回的一系列行和光标的位置，<codeph>LAG</codeph>提供对该位置之前给定物理偏移处的行的访问。
                默认<codeph>offset</codeph>为1。
                <i>default</i>设置当偏移量超出窗口范围时返回的值。
                如果未指定<i>default</i>，则默认值为null。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>last_value(<i>expr</i></codeph>) </entry>
              <entry colname="col2">与输入<i>expr</i>类型相同</entry>
              <entry colname="col3">
                <codeph>LAST_VALUE(<i>expr</i>) OVER ( [PARTITION BY <i>expr</i>] ORDER BY
                    <i>expr</i> [ROWS|RANGE <i>frame_expr</i>] )</codeph>
              </entry>
              <entry colname="col4">返回有序值集中的最后一个值。</entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>
                  <codeph>lead(<i>expr</i> [,<i>offset</i>] [,<i>default</i>])</codeph>
                </codeph>
              </entry>
              <entry colname="col2">与输入<i>expr</i>类型相同</entry>
              <entry colname="col3">
                <codeph>LEAD(<i>expr </i>[,<i>offset</i>] [,<i>expr</i><i>default</i>]) OVER (
                  [PARTITION BY <i>expr</i>] ORDER BY <i>expr</i> )</codeph>
              </entry>
              <entry colname="col4">提供对同一个表的多个行的访问，而无需进行自连接。
                给定从查询返回的一系列行和光标的位置，<codeph>lead</codeph>提供对该位置之后给定物理偏移处的行的访问。
                如果未指定<i>offset</i>，则默认偏移量为1。
                <i>default</i>设置当偏移量超出窗口范围时返回的值。
                如果未指定<i>default</i>，则默认值为null。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>ntile(<i>expr</i>)</codeph>
              </entry>
              <entry colname="col2"><codeph>bigint</codeph></entry>
              <entry colname="col3">
                <codeph>NTILE(<i>expr</i>) OVER ( [PARTITION BY <i>expr</i>] ORDER BY <i>expr</i>
                  )</codeph>
              </entry>
              <entry colname="col4">将有序数据集划分为多个存储桶（由<i>expr</i>定义），并为每行分配存储桶编号。
                </entry>
            </row>
            <row>
              <entry colname="col1"><codeph>percent_rank()</codeph></entry>
              <entry colname="col2">
                <codeph>double precision</codeph>
              </entry>
              <entry colname="col3">
                <codeph>PERCENT_RANK () OVER ( [PARTITION BY <i>expr</i>] ORDER BY <i>expr
                  </i>)</codeph>
              </entry>
              <entry colname="col4">计算假定行<codeph>R</codeph>减1的等级，除以小于被评估的行数（在窗口分区内）的1。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>rank()</codeph>
              </entry>
              <entry colname="col2"><codeph>bigint</codeph></entry>
              <entry colname="col3">
                <codeph>RANK () OVER ( [PARTITION BY <i>expr</i>] ORDER BY <i>expr </i>)</codeph>
              </entry>
              <entry colname="col4">计算有序值组中行的等级。
                排名标准具有相同值的行具有相同的排名。
                绑定行的数量被添加到等级编号以计算下一个等级值。
                在这种情况下，排名可能不是连续的数字。
                </entry>
            </row>
            <row>
              <entry colname="col1"><codeph>row_number()</codeph></entry>
              <entry colname="col2">
                <codeph>bigint</codeph>
              </entry>
              <entry colname="col3">
                <codeph>ROW_NUMBER () OVER ( [PARTITION BY <i>expr</i>] ORDER BY <i>expr
                  </i>)</codeph>
              </entry>
              <entry colname="col4">为应用它的每一行分配一个唯一的编号（窗口分区中的每一行或查询的每一行）。
                </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </body>
  </topic>
  <topic id="topic31" xml:lang="en">
    <title id="in184703">高级聚合函数</title>
    <body>
      <p>以下内置高级分析函数是PostgreSQL数据库的Greenplum扩展。
        分析函数是<i>不可变的</i>。
        </p>
      <note>Greenplum MADlib分析扩展提供了额外的高级功能，可以使用Greenplum数据库数据执行统计分析和机器学习。
        请参阅<xref
          href="extensions/madlib.xml#topic1">Greenplum MADlib分析扩展</xref>。</note>
      <table id="in2073121">
        <title>高级聚合函数</title>
        <tgroup cols="4">
          <colspec colname="col1" colnum="1" colwidth="102.44*"/>
          <colspec colname="col2" colnum="2" colwidth="59*"/>
          <colspec colname="col3" colnum="3" colwidth="201.99*"/>
          <colspec colname="col4" colnum="4" colwidth="128*"/>
          <thead>
            <row>
              <entry colname="col1">函数</entry>
              <entry colname="col2">返回类型</entry>
              <entry colname="col3">完整语法</entry>
              <entry colname="col4">描述</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry colname="col1">
                <codeph>MEDIAN (<i>expr</i>)</codeph>
              </entry>
              <entry colname="col2">
                <codeph>timestamp, timestamptz, interval, float</codeph>
              </entry>
              <entry colname="col3">
                <codeph>MEDIAN (<i>expression</i>)</codeph>
                <p>
                  <i>Example:</i>
                </p>
                <codeblock>SELECT department_id, MEDIAN(salary) 
FROM employees 
GROUP BY department_id; </codeblock>
              </entry>
              <entry colname="col4">可以将二维数组作为输入。
                将这些数组视为矩阵。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>PERCENTILE_CONT (<i>expr</i>) WITHIN GROUP (ORDER BY <i>expr</i>
                  [DESC/ASC])</codeph>
              </entry>
              <entry colname="col2">
                <codeph>timestamp, timestamptz, interval, float</codeph>
              </entry>
              <entry colname="col3">
                <codeph>PERCENTILE_CONT(<i>percentage</i>) WITHIN GROUP (ORDER BY
                  <i>expression</i>)</codeph>
                <p>
                  <i>Example:</i>
                </p>
                <codeblock>SELECT department_id,
PERCENTILE_CONT (0.5) WITHIN GROUP (ORDER BY salary DESC)
"Median_cont"; 
FROM employees GROUP BY department_id;</codeblock>
              </entry>
              <entry colname="col4">执行假设连续分布模型的逆分布函数。
                它采用百分位值和排序规范，并返回与参数的numeric数据类型相同的数据类型。
                该返回值是执行线性插值后的计算结果。
                在此计算中忽略Null。
                </entry>
            </row>
            <row>
              <entry colname="col1"><codeph>PERCENTILE_DISC (<i>expr</i>) WITHIN GROUP (ORDER BY
                    <i>expr</i> [DESC/ASC])</codeph></entry>
              <entry colname="col2">
                <codeph>timestamp, timestamptz, interval, float</codeph>
              </entry>
              <entry colname="col3">
                <codeph>PERCENTILE_DISC(<i>percentage</i>) WITHIN GROUP (ORDER BY
                  <i>expression</i>)</codeph>
                <p>
                  <i>Example:</i>
                </p>
                <codeblock>SELECT department_id, 
PERCENTILE_DISC (0.5) WITHIN GROUP (ORDER BY salary DESC)
"Median_desc"; 
FROM employees GROUP BY department_id;</codeblock>
              </entry>
              <entry colname="col4">执行假设离散分布模型的逆分布函数。
                它需要百分位值和排序规范。
                此返回值是集合中的元素。
                在此计算中忽略Null。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>sum(array[])</codeph>
              </entry>
              <entry colname="col2">
                <codeph>smallint[]int[], bigint[], float[]</codeph>
              </entry>
              <entry colname="col3">
                <codeph>sum(array[[1,2],[3,4]])</codeph>
                <p>
                  <i>Example:</i>
                </p>
                <codeblock>CREATE TABLE mymatrix (myvalue int[]);
INSERT INTO mymatrix VALUES (array[[1,2],[3,4]]);
INSERT INTO mymatrix VALUES (array[[0,1],[1,0]]);
SELECT sum(myvalue) FROM mymatrix;
 sum 
---------------
 {{1,3},{4,4}}</codeblock>
              </entry>
              <entry colname="col4">执行矩阵求和。
                可以将被视为矩阵的二维数组作为输入。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>pivot_sum (label[], label, expr)</codeph>
              </entry>
              <entry colname="col2">
                <codeph>int[], bigint[], float[]</codeph>
              </entry>
              <entry colname="col3">
                <codeph>pivot_sum( array['A1','A2'], attr, value)</codeph>
              </entry>
              <entry colname="col4">使用sum的数据透视聚合来解决重复的条目。
                </entry>
            </row>
            <row>
              <entry colname="col1">
                <codeph>unnest (array[])</codeph>
              </entry>
              <entry colname="col2">set of <codeph>anyelement</codeph></entry>
              <entry colname="col3">
                <codeph>unnest( array['one', 'row', 'per', 'item'])</codeph>
              </entry>
              <entry colname="col4">将一维数组转换为行。
                返回一组<codeph>anyelement</codeph>，
                多态的<xref format="html"
                         href="https://www.postgresql.org/docs/9.4/datatype-pseudo.html" scope="external"
                ><ph>PostgreSQL中的假型</ph></xref>。
                </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </body>
  </topic>
  <topic id="topic_vpj_ss1_lfb">
    <title>文本搜索函数和操作符</title>
    <body>
      <p>下表总结了为全文搜索提供的函数和运算符。
        有关Greenplum数据库文本搜索工具的详细说明，
        请参阅<xref href="../admin_guide/textsearch/full-text-search.xml"/>。
      </p>
      <table id="table_t3f_vs1_lfb">
        <title>文本搜索运算符</title>
        <tgroup cols="4">
          <colspec colnum="1" colname="col1"/>
          <colspec colnum="2" colname="col2"/>
          <colspec colnum="3" colname="col3"/>
          <colspec colnum="4" colname="col4"/>
          <thead>
            <row>
              <entry>操作符</entry>
              <entry>描述</entry>
              <entry>示例</entry>
              <entry>结果</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><codeph>@@</codeph></entry>
              <entry><codeph>tsvector</codeph>匹配<codeph>tsquery</codeph> ?</entry>
              <entry><codeph>to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp;
                  rat')</codeph></entry>
              <entry><codeph>t</codeph></entry>
            </row>
            <row>
              <entry><codeph>@@@</codeph></entry>
              <entry><codeph>@@</codeph>的弃用同义词</entry>
              <entry><codeph>to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp;
                  rat')</codeph></entry>
              <entry><codeph>t</codeph></entry>
            </row>
            <row>
              <entry><codeph>||</codeph></entry>
              <entry>连接<codeph> tsvector</codeph>s</entry>
              <entry><codeph>'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector</codeph></entry>
              <entry><codeph>'a':1 'b':2,5 'c':3 'd':4</codeph></entry>
            </row>
            <row>
              <entry><codeph>&amp;&amp;</codeph></entry>
              <entry>AND <codeph>tsquery</codeph>s 一起</entry>
              <entry><codeph>'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery</codeph></entry>
              <entry><codeph>( 'fat' | 'rat' ) &amp; 'cat'</codeph></entry>
            </row>
            <row>
              <entry><codeph>||</codeph></entry>
              <entry>OR <codeph>tsquery</codeph>s 一起</entry>
              <entry><codeph>'fat | rat'::tsquery || 'cat'::tsquery</codeph></entry>
              <entry><codeph>( 'fat' | 'rat' ) | 'cat'</codeph></entry>
            </row>
            <row>
              <entry><codeph>!!</codeph></entry>
              <entry>否定一个<codeph> tsquery</codeph></entry>
              <entry><codeph>!! 'cat'::tsquery</codeph></entry>
              <entry><codeph>!'cat'</codeph></entry>
            </row>
            <row>
              <entry><codeph>@></codeph></entry>
              <entry><codeph>tsquery</codeph>是否包含另一个？</entry>
              <entry><codeph>'cat'::tsquery @> 'cat &amp; rat'::tsquery</codeph></entry>
              <entry><codeph>f</codeph></entry>
            </row>
            <row>
              <entry><codeph>&lt;@</codeph></entry>
              <entry><codeph>tsquery</codeph>是否包含在？</entry>
              <entry><codeph>'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery</codeph></entry>
              <entry><codeph>t</codeph></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note><codeph>tsquery</codeph>包含运算符仅考虑两个查询中列出的词位，忽略组合运算符。
        </note>
      <p>除了表中显示的运算符之外，还为类型<codeph>tsvector</codeph>和<codeph>tsquery</codeph>定义了普通的B树比较运算符（=, &lt;, 等）。
        这些对于文本搜索不是很有用，但允许在这些类型的列上构建唯一索引。
        </p>
      <table id="table_u3f_vs1_lfb">
        <title>文本搜索函数</title>
        <tgroup cols="5">
          <colspec colnum="1" colname="col1"/>
          <colspec colnum="2" colname="col2"/>
          <colspec colnum="3" colname="col3"/>
          <colspec colnum="4" colname="col4"/>
          <colspec colnum="5" colname="col5"/>
          <thead>
            <row>
              <entry>函数</entry>
              <entry>返回类型</entry>
              <entry>描述</entry>
              <entry>示例</entry>
              <entry>结果</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><codeph>get_current_ts_config()</codeph></entry>
              <entry>regconfig</entry>
              <entry>获取默认文本搜索配置</entry>
              <entry>get_current_ts_config()</entry>
              <entry>english</entry>
            </row>
            <row>
              <entry><codeph>length(tsvector)</codeph></entry>
              <entry>integer</entry>
              <entry>tsvector中的词位数</entry>
              <entry>length('fat:2,4 cat:3 rat:5A'::tsvector)</entry>
              <entry>3</entry>
            </row>
            <row>
              <entry><codeph>numnode(tsquery)</codeph></entry>
              <entry>integer</entry>
              <entry>词位数加tsquery中的运算符的数量</entry>
              <entry>numnode('(fat &amp; rat) | cat'::tsquery)</entry>
              <entry>5</entry>
            </row>
            <row>
              <entry><codeph>plainto_tsquery([ config regconfig , ] querytext)</codeph></entry>
              <entry>tsquery</entry>
              <entry>产生忽略标点符号的tsquery</entry>
              <entry>plainto_tsquery('english', 'The Fat Rats')</entry>
              <entry>'fat' &amp; 'rat'</entry>
            </row>
            <row>
              <entry><codeph>querytree(query tsquery)</codeph></entry>
              <entry>text</entry>
              <entry>获得tsquery的可索引部分</entry>
              <entry>querytree('foo &amp; ! bar'::tsquery)</entry>
              <entry>'foo'</entry>
            </row>
            <row>
              <entry><codeph>setweight(tsvector, "char")</codeph></entry>
              <entry>tsvector</entry>
              <entry>为tsvector的每个元素赋予权重</entry>
              <entry>setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')</entry>
              <entry>'cat':3A 'fat':2A,4A 'rat':5A</entry>
            </row>
            <row>
              <entry><codeph>strip(tsvector)</codeph></entry>
              <entry>tsvector</entry>
              <entry>从tsvector中删除位置和权重</entry>
              <entry>strip('fat:2,4 cat:3 rat:5A'::tsvector)</entry>
              <entry>'cat' 'fat' 'rat'</entry>
            </row>
            <row>
              <entry><codeph>to_tsquery([ config regconfig , ] query text)</codeph></entry>
              <entry>tsquery</entry>
              <entry>规范化单词并转换为tsquery</entry>
              <entry>to_tsquery('english', 'The &amp; Fat &amp; Rats')</entry>
              <entry>'fat' &amp; 'rat'</entry>
            </row>
            <row>
              <entry><codeph>to_tsvector([ config regconfig , ] documenttext)</codeph></entry>
              <entry>tsvector</entry>
              <entry>将文档文本缩减为tsvector</entry>
              <entry>to_tsvector('english', 'The Fat Rats')</entry>
              <entry>'fat':2 'rat':3</entry>
            </row>
            <row>
              <entry><codeph>ts_headline([ config regconfig, ] documenttext, query tsquery [,
                  options text ])</codeph></entry>
              <entry>text</entry>
              <entry>显示查询匹配</entry>
              <entry>ts_headline('x y z', 'z'::tsquery)</entry>
              <entry>x y &lt;b>z&lt;/b></entry>
            </row>
            <row>
              <entry><codeph>ts_rank([ weights float4[], ] vector tsvector,query tsquery [,
                  normalization integer ])</codeph></entry>
              <entry>float4</entry>
              <entry>用于查询的排名文档</entry>
              <entry>ts_rank(textsearch, query)</entry>
              <entry>0.818</entry>
            </row>
            <row>
              <entry><codeph>ts_rank_cd([ weights float4[], ] vectortsvector, query tsquery [,
                  normalizationinteger ])</codeph></entry>
              <entry>float4</entry>
              <entry>使用封面密度对查询进行排名</entry>
              <entry>ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)</entry>
              <entry>2.01317</entry>
            </row>
            <row>
              <entry><codeph>ts_rewrite(query tsquery, target tsquery,substitute
                tsquery)</codeph></entry>
              <entry>tsquery</entry>
              <entry>在查询中用substitute替换目标</entry>
              <entry>ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)</entry>
              <entry>'b' &amp; ( 'foo' | 'bar' )</entry>
            </row>
            <row>
              <entry><codeph>ts_rewrite(query tsquery, select text)</codeph></entry>
              <entry>tsquery</entry>
              <entry>使用targets和substitutes从SELECT命令中替换</entry>
              <entry>SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')</entry>
              <entry>'b' &amp; ( 'foo' | 'bar' )</entry>
            </row>
            <row>
              <entry><codeph>tsvector_update_trigger()</codeph></entry>
              <entry>trigger</entry>
              <entry>用于自动tsvector列更新的触发器函数</entry>
              <entry>CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', title,
                body)</entry>
              <entry/>
            </row>
            <row>
              <entry><codeph>tsvector_update_trigger_column()</codeph></entry>
              <entry>trigger</entry>
              <entry>用于自动tsvector列更新的触发器函数</entry>
              <entry>CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title,
                body)</entry>
              <entry/>
            </row>
          </tbody>
        </tgroup>
      </table>
      <note>接受可选的<codeph>regconfig</codeph>参数的所有文本搜索函数将在省略该参数时使用<xref
              href="config_params/guc-list.xml#default_text_search_config"/>指定的配置。
        </note>
      <p>下表中的功能单独列出，因为它们通常不用于日常文本搜索操作。
        它们有助于开发和调试新的文本搜索配置。
        </p>
      <table id="table_v3f_vs1_lfb">
        <title>文本搜索调试函数</title>
        <tgroup cols="5">
          <colspec colnum="1" colname="col1"/>
          <colspec colnum="2" colname="col2"/>
          <colspec colnum="3" colname="col3"/>
          <colspec colnum="4" colname="col4"/>
          <colspec colnum="5" colname="col5"/>
          <thead>
            <row>
              <entry>函数</entry>
              <entry>返回类型</entry>
              <entry>描述</entry>
              <entry>示例</entry>
              <entry>结果</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry><codeph>ts_debug([ <i>config</i> regconfig, ] <i>document</i> text, OUT
                    <i>alias</i> text, OUT <i>description</i> text, OUT <i>token</i> text, OUT
                    <i>dictionaries</i> regdictionary[], OUT <i>dictionary</i> regdictionary, OUT
                    <i>lexemes</i> text[])</codeph></entry>
              <entry><codeph>setof record</codeph></entry>
              <entry>测试配置</entry>
              <entry><codeph>ts_debug('english', 'The Brightest supernovaes')</codeph></entry>
              <entry><codeph>(asciiword,"Word, all ASCII",The,{english_stem},english_stem,{})
                  ...</codeph></entry>
            </row>
            <row>
              <entry><codeph>ts_lexize(<i>dict</i> regdictionary, <i>token</i>
                text)</codeph></entry>
              <entry><codeph>text[]</codeph></entry>
              <entry>测试字典</entry>
              <entry><codeph>ts_lexize('english_stem', 'stars')</codeph></entry>
              <entry><codeph>{star}</codeph></entry>
            </row>
            <row>
              <entry><codeph>ts_parse(<i>parser_name</i> text, <i>document</i> text, OUT
                    <i>tokid</i> integer, OUT <i>token</i> text)</codeph></entry>
              <entry><codeph>setof record</codeph></entry>
              <entry>测试解析器</entry>
              <entry><codeph>ts_parse('default', 'foo - bar')</codeph></entry>
              <entry>(<codeph><codeph>1,foo) ...</codeph></codeph></entry>
            </row>
            <row>
              <entry><codeph>ts_parse(<i>parser_oid</i> oid, <i>document</i> text, OUT <i>tokid</i>
                  integer, OUT <i>token</i> text)</codeph></entry>
              <entry><codeph>setof record</codeph></entry>
              <entry>测试解析器</entry>
              <entry><codeph>ts_parse(3722, 'foo - bar')</codeph></entry>
              <entry><codeph>(1,foo) ...</codeph></entry>
            </row>
            <row>
              <entry><codeph>ts_token_type(<i>parser_name</i> text, OUT <i>tokid</i> integer, OUT
                    <i>alias</i> text, OUT description text)</codeph></entry>
              <entry><codeph>setof record</codeph></entry>
              <entry>获取解析器定义的token类型</entry>
              <entry><codeph>ts_token_type('default')</codeph></entry>
              <entry><codeph>(1,asciiword,"Word, all ASCII") ...</codeph></entry>
            </row>
            <row>
              <entry><codeph>ts_token_type(<i>parser_oid</i> oid, OUT <i>tokid</i> integer, OUT
                    <i>alias</i> text, OUT <i>description</i> text)</codeph></entry>
              <entry><codeph>setof record</codeph></entry>
              <entry>获取解析器定义的token类型</entry>
              <entry><codeph>ts_token_type(3722)</codeph></entry>
              <entry><codeph>(1,asciiword,"Word, all ASCII") ...</codeph></entry>
            </row>
            <row>
              <entry><codeph>ts_stat(<i>sqlquery</i> text, [ <i>weights</i> text, ] OUT <i>word</i>
                  text, OUT <i>ndocinteger</i>, OUT <i>nentry</i> integer)</codeph></entry>
              <entry><codeph>setof record</codeph></entry>
              <entry>获取tsvectorcolumn的统计信息</entry>
              <entry><codeph>ts_stat('SELECT vector from apod')</codeph></entry>
              <entry><codeph>(foo,10,15) ...</codeph></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </body>
  </topic>
  <topic xml:lang="en-us" id="functions-range">
    <title>范围函数和运算符</title>
    <body>
      <p>有关范围类型的概述，请参阅<xref href="datatype-range.xml#rangetypes"/>。</p>
      <p>下表显示了可用于范围类型的运算符。</p>
      <table id="range-operators-table">
        <title>范围运算符</title>
        <tgroup cols="4">
          <thead>
            <row>
              <entry>运算符</entry>
              <entry>描述</entry>
              <entry>示例</entry>
              <entry>结果</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <codeph>=</codeph>
              </entry>
              <entry>相等</entry>
              <entry>
                <codeph>int4range(1,5) = '[1,4]'::int4range</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&lt;&gt;</codeph>
              </entry>
              <entry>不相等</entry>
              <entry>
                <codeph>numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&lt;</codeph>
              </entry>
              <entry>小于</entry>
              <entry>
                <codeph>int4range(1,10) &lt; int4range(2,3)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&gt;</codeph>
              </entry>
              <entry>大于</entry>
              <entry>
                <codeph>int4range(1,10) &gt; int4range(1,5)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&lt;=</codeph>
              </entry>
              <entry>小于等于</entry>
              <entry>
                <codeph>numrange(1.1,2.2) &lt;= numrange(1.1,2.2)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&gt;=</codeph>
              </entry>
              <entry>大于等于</entry>
              <entry>
                <codeph>numrange(1.1,2.2) &gt;= numrange(1.1,2.0)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>@&gt;</codeph>
              </entry>
              <entry>包含范围</entry>
              <entry>
                <codeph>int4range(2,4) @&gt; int4range(2,3)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>@&gt;</codeph>
              </entry>
              <entry>包含元素</entry>
              <entry>
                <codeph>'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&lt;@</codeph>
              </entry>
              <entry>范围包含在</entry>
              <entry>
                <codeph>int4range(2,4) &lt;@ int4range(1,7)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&lt;@</codeph>
              </entry>
              <entry>元素包含在</entry>
              <entry>
                <codeph>42 &lt;@ int4range(1,7)</codeph>
              </entry>
              <entry>
                <codeph>f</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&amp;&amp;</codeph>
              </entry>
              <entry>重叠（有共同点）</entry>
              <entry>
                <codeph>int8range(3,7) &amp;&amp; int8range(4,12)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&lt;&lt;</codeph>
              </entry>
              <entry>严格小于</entry>
              <entry>
                <codeph>int8range(1,10) &lt;&lt; int8range(100,110)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&gt;&gt;</codeph>
              </entry>
              <entry>严格大于</entry>
              <entry>
                <codeph>int8range(50,60) &gt;&gt; int8range(20,30)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&amp;&lt;</codeph>
              </entry>
              <entry>没有超越右边</entry>
              <entry>
                <codeph>int8range(1,20) &amp;&lt; int8range(18,20)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>&amp;&gt;</codeph>
              </entry>
              <entry>没有超越左边</entry>
              <entry>
                <codeph>int8range(7,20) &amp;&gt; int8range(5,10)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>-|-</codeph>
              </entry>
              <entry>毗邻</entry>
              <entry>
                <codeph>numrange(1.1,2.2) -|- numrange(2.2,3.3)</codeph>
              </entry>
              <entry>
                <codeph>t</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>+</codeph>
              </entry>
              <entry>并集</entry>
              <entry>
                <codeph>numrange(5,15) + numrange(10,20)</codeph>
              </entry>
              <entry>
                <codeph>[5,20)</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>*</codeph>
              </entry>
              <entry>交集</entry>
              <entry>
                <codeph>int8range(5,15) * int8range(10,20)</codeph>
              </entry>
              <entry>
                <codeph>[10,15)</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>-</codeph>
              </entry>
              <entry>差集</entry>
              <entry>
                <codeph>int8range(5,15) - int8range(10,20)</codeph>
              </entry>
              <entry>
                <codeph>[5,10)</codeph>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <p>简单比较运算符<codeph>&lt;</codeph>，<codeph>&gt;</codeph>，<codeph>&lt;=</codeph>和<codeph>&gt;=</codeph>首先比较下限，只有在相等的情况下，才比较上限。
        这些比较通常对范围不是很有用，但提供的是允许在范围上构建B树索引。
        </p>
      <p>当涉及空范围时，左/右/邻接运算符总是返回false; 也就是说，空范围不被认为是在任何其他范围之前或之后。
        </p>
      <p>如果结果范围需要包含两个不相交的子范围，则并集和差异运算符将失败，因为无法表示这样的范围。
        </p>
      <p>下表显示了可用于范围类型的函数。</p>
      <table id="range-functions-table">
        <title>范围函数</title>
        <tgroup cols="5">
          <thead>
            <row>
              <entry>函数</entry>
              <entry>返回类型</entry>
              <entry>描述</entry>
              <entry>示例</entry>
              <entry>结果</entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <codeph>
                  <codeph>lower</codeph>(<codeph>anyrange</codeph>) </codeph>
              </entry>
              <entry>范围的元素类型</entry>
              <entry>范围的下限</entry>
              <entry>
                <codeph>lower(numrange(1.1,2.2))</codeph>
              </entry>
              <entry>
                <codeph>1.1</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>
                  <codeph>upper</codeph>(<codeph>anyrange</codeph>) </codeph>
              </entry>
              <entry>范围的元素类型</entry>
              <entry>范围的上限</entry>
              <entry>
                <codeph>upper(numrange(1.1,2.2))</codeph>
              </entry>
              <entry>
                <codeph>2.2</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>
                  <codeph>isempty</codeph>(<codeph>anyrange</codeph>) </codeph>
              </entry>
              <entry>
                <codeph>boolean</codeph>
              </entry>
              <entry>范围是否空？</entry>
              <entry>
                <codeph>isempty(numrange(1.1,2.2))</codeph>
              </entry>
              <entry>
                <codeph>false</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>
                  <codeph>lower_inc</codeph>(<codeph>anyrange</codeph>) </codeph>
              </entry>
              <entry>
                <codeph>boolean</codeph>
              </entry>
              <entry>是否包含下限？</entry>
              <entry>
                <codeph>lower_inc(numrange(1.1,2.2))</codeph>
              </entry>
              <entry>
                <codeph>true</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>
                  <codeph>upper_inc</codeph>(<codeph>anyrange</codeph>) </codeph>
              </entry>
              <entry>
                <codeph>boolean</codeph>
              </entry>
              <entry>是否包含上限？</entry>
              <entry>
                <codeph>upper_inc(numrange(1.1,2.2))</codeph>
              </entry>
              <entry>
                <codeph>false</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>
                  <codeph>lower_inf</codeph>(<codeph>anyrange</codeph>) </codeph>
              </entry>
              <entry>
                <codeph>boolean</codeph>
              </entry>
              <entry>下限是否无穷小？</entry>
              <entry>
                <codeph>lower_inf('(,)'::daterange)</codeph>
              </entry>
              <entry>
                <codeph>true</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>
                  <codeph>upper_inf</codeph>(<codeph>anyrange</codeph>) </codeph>
              </entry>
              <entry>
                <codeph>boolean</codeph>
              </entry>
              <entry>上限是否无穷大？</entry>
              <entry>
                <codeph>upper_inf('(,)'::daterange)</codeph>
              </entry>
              <entry>
                <codeph>true</codeph>
              </entry>
            </row>
            <row>
              <entry>
                <codeph>
                  <codeph>range_merge</codeph>(<codeph>anyrange</codeph>, <codeph>anyrange</codeph>)
                </codeph>
              </entry>
              <entry>
                <codeph>anyrange</codeph>
              </entry>
              <entry>包括两个给定范围的最小范围</entry>
              <entry>
                <codeph>range_merge('[1,2)'::int4range, '[3,4)'::int4range)</codeph>
              </entry>
              <entry>
                <codeph>[1,4)</codeph>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <p>如果范围为空或请求的边界为无限，则<codeph>lower</codeph>和<codeph>upper</codeph>函数返回null。
        对于空范围，<codeph>lower_inc</codeph>，<codeph>upper_inc</codeph>，<codeph>lower_inf</codeph>和<codeph>upper_inf</codeph>函数都返回false。
        </p>
    </body>
  </topic>
</topic>
